===== app.js ===== 
// app.js
const express = require("express");
const cookieParser = require("cookie-parser");
const cors = require("cors");

// Import routes
const adminRoutes = require("../src/routes/admin/adminRoutes");
const otpRoutes = require("../src/routes/otpRoutes");
const coachRoutes = require("../src/routes/coach/coachRoutes");
const activitiesRoutes = require("./routes/activities/activitiesRoute");

const app = express();

// trust proxy for rate limiting & X-Forwarded-For
app.set("trust proxy", 1); // trust first proxy (nginx/pm2)

// Read upload base path from .env
const { UPLOADS_BASE_PATH } = process.env;

// Read allowed origins from .env
const allowedOrigins = process.env.ALLOWED_ORIGINS
  ? process.env.ALLOWED_ORIGINS.split(",").map((origin) => origin.trim())
  : [];

// Middlewares
app.use(express.json());
app.use(cookieParser());
app.use(
  cors({
    origin: (origin, callback) => {
      // Allow requests with no origin (mobile apps, Postman, curl)
      if (!origin || allowedOrigins.includes(origin)) {
        callback(null, true);
      } else {
        callback(new Error(`❌ CORS blocked: ${origin}`));
      }
    },
    credentials: true, // so cookies like AuthToken work in browsers
  })
);

// API routes
app.use("/admin", adminRoutes);
app.use("/otp", otpRoutes);
app.use("/coach", coachRoutes);
app.use("/activities", activitiesRoutes);

// Health check /health default route
app.get("/health", (req, res) => {
  res.status(200).json({ status: "ok" });
});

// / default route of the application
app.get("/", (req, res) => {
  res.send("Welcome to Cue Wellness Backend API 🚀");
});

// static middleware to serve images/videos from /uploads:
app.use("/uploads", express.static(UPLOADS_BASE_PATH));

module.exports = app;

===== server.js ===== 
// server.js
const app = require("./app");
const connectToDatabase = require("./configs/dbConfig");

const PORT = process.env.PORT || 9000;

async function startServer() {
  try {
    // Connect to MongoDB
    connectToDatabase();

    // Start Express server
    app.listen(PORT, () => {
      console.log(`🚀 Server running on http://localhost:${PORT}`);
    });
  } catch (error) {
    console.error("❌ Server failed to start:", error);
    process.exit(1);
  }
}

module.exports = { startServer };

===== dbConfig.js ===== 
const mongoose = require("mongoose");
require("dotenv").config();

function connectToDatabase() {
  const dbMode = process.env.DB_MODE || "local";

  let uri;

  if (dbMode === "remote") {
    uri = `mongodb://${process.env.REMOTE_DB_USER}:${process.env.REMOTE_DB_PASS}@${process.env.REMOTE_DB_IP}:27017/${process.env.REMOTE_DB_NAME}?authSource=admin`;
  } else {
    uri = process.env.MONGO_URI_LOCAL;
  }

  mongoose.connect(uri);

  const db = mongoose.connection;
  db.on("error", console.error.bind(console, "MongoDB connection error:"));
  db.once("open", () => {
    console.log(`✅ Connected to MongoDB (${dbMode})`);
  });
}

module.exports = connectToDatabase;
:
===== permissionConfig.js ===== 
module.exports = {
  "admin:add": "manage-staff:add",
  "admin:list": "manage-staff:view",
  "admin:get": "manage-staff:view",
  "admin:update": "manage-staff:edit",
  "admin:delete": "manage-staff:delete",
  "coach:list": "manage-coach:view",
  "coach:get": "manage-coach:view",
  "coach:update": "manage-coach:edit",
  "coach:delete": "manage-coach:delete",
  "coach:changeStatus": "manage-coach:change-status",
  "activities:add": "manage-activities:add",
  "activities:list": "manage-activities:view",
  "activities:get": "manage-activities:view",
  "activities:update": "manage-activities:edit",
  "activities:delete": "manage-activities:delete",
};
:
===== uploadConfig.js ===== 
const multer = require("multer");
const path = require("path");
const fs = require("fs");

const {
  UPLOADS_BASE_PATH = path.join(process.cwd(), "uploads"),
  PROFILE_PIC_PATH = "profile_pics",
  CERTIFICATES_PATH = "certificates",
  WORK_ASSETS_PATH = "work_assets",
} = process.env;

function ensureDir(dir) {
  if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });
}

function makeStorage(subFolder, prefix) {
  const uploadPath = path.join(UPLOADS_BASE_PATH, subFolder);
  ensureDir(uploadPath);

  return multer.diskStorage({
    destination: (req, file, cb) => cb(null, uploadPath),
    filename: (req, file, cb) => {
      const ext = path.extname(file.originalname) || "";
      cb(
        null,
        `${prefix}_${Date.now()}_${Math.round(Math.random() * 1e9)}${ext}`
      );
    },
  });
}

module.exports = {
  profilePicUpload: multer({
    storage: makeStorage(PROFILE_PIC_PATH, "profile"),
  }),
  certificateUpload: multer({
    storage: makeStorage(CERTIFICATES_PATH, "certificate"),
  }),
  workAssetUpload: multer({ storage: makeStorage(WORK_ASSETS_PATH, "work") }),
};
:
===== otpController.js ===== 
const otpService = require("../services/otpService");
const { logError } = require("../utils/errorLogger.util");

const ALLOWED_USER_TYPES = [
  "client",
  "coach",
  "eventOrganizer",
  "productCompany",
];
/**
 * POST /api/otp/send
 * body: { phone: "+97150...", userType: "coach", operation: "login" }
 */
async function sendOtp(req, res) {
  try {
    const { phone, userType, meta, operation } = req.body;
    if (!phone) {
      await logError({
        name: "sendOtp_missing_phone",
        file: "controllers/otpController.js",
        description: "phone missing from request body",
        section: "otp",
        priority: "low",
      });
      return res.status(400).json({ ok: false, message: "phone required" });
    }

    const ut = userType || "client";
    if (!ALLOWED_USER_TYPES.includes(ut)) {
      await logError({
        name: "sendOtp_invalid_userType",
        file: "controllers/otpController.js",
        description: `Invalid userType ${ut}`,
        section: "otp",
        priority: "low",
      });
      return res.status(400).json({ ok: false, message: "Invalid userType" });
    }

    const result = await otpService.createAndSendOtp(phone, {
      userType: ut,
      meta: meta || { ip: req.ip },
      operation: operation || "login",
    });
    return res.status(201).json({ ok: true, ...result });
  } catch (err) {
    await logError({
      name: "sendOtp_exception",
      file: "controllers/otpController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "otp",
      priority: "high",
    });
    console.error("sendOtp error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Error sending OTP", error: err.message });
  }
}

/**
 * POST /api/otp/verify
 * body: { otpId: "<encrypted>", otp: "123456" }
 */
async function verifyOtp(req, res) {
  try {
    const { otpId, otp } = req.body;
    if (!otpId || !otp) {
      await logError({
        name: "verifyOtp_missing_fields",
        file: "controllers/otpController.js",
        description: "otpId and/or otp missing",
        section: "otp",
        priority: "low",
      });
      return res
        .status(400)
        .json({ ok: false, message: "otpId and otp required" });
    }

    const result = await otpService.verifyOtp(otpId, otp);
    if (result.ok) {
      return res.status(200).json({
        ok: true,
        message: "Verified",
        recordId: result.record._id,
        userType: result.record.userType,
        phone: result.record.phone,
      });
    }

    // Log verification failure with different priorities
    const reason = result.reason || "unknown";
    const priority =
      reason === "invalid_otpId" || reason === "expired"
        ? "medium"
        : reason === "max_attempts"
        ? "high"
        : "low";
    await logError({
      name: `verifyOtp_${reason}`,
      file: "controllers/otpController.js",
      description: `verifyOtp failed: reason=${reason}`,
      section: "otp",
      priority,
    });

    switch (reason) {
      case "expired":
        return res.status(410).json({ ok: false, message: "OTP expired" });
      case "max_attempts":
        return res
          .status(429)
          .json({ ok: false, message: "Maximum attempts exceeded" });
      case "invalid_code":
      case "invalid_otpId":
      default:
        return res
          .status(401)
          .json({ ok: false, message: "Invalid OTP or OTP ID" });
    }
  } catch (err) {
    await logError({
      name: "verifyOtp_exception",
      file: "controllers/otpController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "otp",
      priority: "high",
    });
    console.error("verifyOtp error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Verification failed", error: err.message });
  }
}

/**
 * POST /api/otp/resend
 * body: { otpId: "<encrypted>" }
 */
async function resendOtp(req, res) {
  try {
    const { otpId } = req.body;
    if (!otpId) {
      await logError({
        name: "resendOtp_missing_otpId",
        file: "controllers/otpController.js",
        description: "otpId missing from request body",
        section: "otp",
        priority: "low",
      });
      return res.status(400).json({ ok: false, message: "otpId required" });
    }

    const result = await otpService.resendOtp(otpId);
    if (result.ok === true) {
      return res.status(200).json({ ok: true, message: "OTP resent" });
    }
    if (result.otpId) {
      return res.status(200).json({ ok: true, ...result });
    }

    // log resend failure
    await logError({
      name: `resendOtp_${result.reason || "failed"}`,
      file: "controllers/otpController.js",
      description: `resendOtp failed: reason=${result.reason || "unknown"}`,
      section: "otp",
      priority: result.reason === "resend_limit_reached" ? "medium" : "low",
    });

    return res.status(400).json({
      ok: false,
      message: "Could not resend OTP",
      reason: result.reason,
    });
  } catch (err) {
    await logError({
      name: "resendOtp_exception",
      file: "controllers/otpController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "otp",
      priority: "high",
    });
    console.error("resendOtp error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Error resending OTP", error: err.message });
  }
}

module.exports = {
  sendOtp,
  verifyOtp,
  resendOtp,
};
:
===== activitiesController.js ===== 
// controllers/activities/activitiesController.js
const activityService = require("../../services/activities/activitiesService");
const { logError } = require("../../utils/errorLogger.util");

async function addActivityOrSubActivity(req, res) {
  try {
    const { title, parent_id } = req.body;
    if (!title)
      return res.status(400).json({ ok: false, message: "title required" });
    const result = await activityService.addActivityOrSubActivity(
      title,
      parent_id
    );
    return res.status(201).json({ ok: true, message: "Created", data: result });
  } catch (err) {
    await logError({
      name: "addActivityOrSubActivity_exception",
      file: "controllers/activities/activitiesController.js",
      description: err && err.message ? err.message : String(err),
      section: "activities",
      priority: "high",
    });
    return res.status(500).json({ ok: false, message: err.message });
  }
}

async function listActivities(req, res) {
  try {
    const parentId = req.query.parentId || null;
    if (!parentId) {
      // return root items
      const roots = await activityService.listRootActivities();
      return res.status(200).json({ ok: true, data: roots });
    } else {
      const children = await activityService.listChildren(parentId);
      return res.status(200).json({ ok: true, data: children });
    }
  } catch (err) {
    await logError({
      name: "listActivities_exception",
      file: "controllers/activities/activitiesController.js",
      description: err && err.message ? err.message : String(err),
      section: "activities",
      priority: "high",
    });
    return res.status(500).json({ ok: false, message: err.message });
  }
}

async function updateActivity(req, res) {
  try {
    const { id } = req.params;
    const { title } = req.body;
    if (!title)
      return res.status(400).json({ ok: false, message: "title required" });
    const updated = await activityService.updateActivity(id, title);
    if (!updated)
      return res.status(404).json({ ok: false, message: "Not found" });
    return res.status(200).json({ ok: true, data: updated });
  } catch (err) {
    await logError({
      name: "updateActivity_exception",
      file: "controllers/activities/activitiesController.js",
      description: err && err.message ? err.message : String(err),
      section: "activities",
      priority: "high",
    });
    return res.status(500).json({ ok: false, message: err.message });
  }
}

async function deleteActivity(req, res) {
  try {
    const { id } = req.params;
    const ok = await activityService.deleteActivity(id);
    if (!ok) return res.status(404).json({ ok: false, message: "Not found" });
    return res.status(200).json({ ok: true, message: "Deleted" });
  } catch (err) {
    await logError({
      name: "deleteActivity_exception",
      file: "controllers/activities/activitiesController.js",
      description: err && err.message ? err.message : String(err),
      section: "activities",
      priority: "high",
    });
    return res.status(500).json({ ok: false, message: err.message });
  }
}

module.exports = {
  addActivityOrSubActivity,
  listActivities,
  updateActivity,
  deleteActivity,
};
:
===== adminController.js ===== 
const adminService = require("../../services/admin/adminService");
const {
  signAccessToken,
  generateRefreshTokenPlain,
  hashRefreshToken,
} = require("../../utils/jwt.util");

const {
  addAdminSchema,
  loginSchema,
  updateAdminSchema,
} = require("../../validators/admin.validator");
const logger = require("../../utils/logger");

// Standard response helper
function send(res, status, payload) {
  return res
    .status(status)
    .json({ success: payload.success !== false, ...payload });
}

// Add admin (only accessible to superAdmin or permitted)
async function addAdmin(req, res) {
  try {
    const { error, value } = addAdminSchema.validate(req.body);
    if (error)
      return send(res, 400, { success: false, message: error.message });

    // Only superAdmin can create another superAdmin or set permissions
    if (value.superAdmin && !req.admin?.superAdmin) {
      return send(res, 403, {
        success: false,
        message: "Only superAdmin can create superAdmin",
      });
    }

    // Create
    const existing = await adminService.checkAdminByMobileOrEmail(
      value.mobile,
      value.email
    );
    if (existing)
      return send(res, 409, {
        success: false,
        message: "Admin already exists",
      });

    const newAdmin = await adminService.createAdmin(
      value,
      req.admin?._id || null
    );
    const result = {
      id: newAdmin._id,
      name: newAdmin.name,
      mobile: newAdmin.mobile,
      email: newAdmin.email,
    };
    return send(res, 201, {
      success: true,
      message: "Admin added",
      data: result,
    });
  } catch (err) {
    logger.error("addAdmin error: %o", err);
    return send(res, 500, { success: false, message: "Error adding admin" });
  }
}

async function updateAdmin(req, res) {
  try {
    const { error, value } = updateAdminSchema.validate(req.body);
    if (error)
      return send(res, 400, { success: false, message: error.message });

    // Prevent modifications to sensitive fields via this endpoint
    // Only superAdmin can update permissions/superAdmin - enforce at route-level if needed
    const updated = await adminService.updateAdmin(
      req.params.id,
      value,
      req.admin?._id || null
    );
    if (!updated)
      return send(res, 404, { success: false, message: "Admin not found" });
    return send(res, 200, { success: true, message: "Updated", data: updated });
  } catch (err) {
    logger.error("updateAdmin error: %o", err);
    return send(res, 500, { success: false, message: "Error updating admin" });
  }
}

async function deleteAdmin(req, res) {
  try {
    // prevent self-delete
    if (
      req.admin &&
      req.admin._id &&
      req.admin._id.toString() === req.params.id
    ) {
      return send(res, 400, {
        success: false,
        message: "Admins cannot delete themselves",
      });
    }
    const deleted = await adminService.deleteAdmin(req.params.id);
    if (!deleted)
      return send(res, 404, { success: false, message: "Admin not found" });
    return send(res, 200, { success: true, message: "Deleted" });
  } catch (err) {
    logger.error("deleteAdmin error: %o", err);
    return send(res, 500, { success: false, message: "Error deleting admin" });
  }
}

async function listAdmins(req, res) {
  try {
    const { page = 1, limit = 20 } = req.query;
    const data = await adminService.listAdmins({ page, limit });
    return send(res, 200, { success: true, message: "Success", data });
  } catch (err) {
    logger.error("listAdmins error: %o", err);
    return send(res, 500, { success: false, message: "Error listing admins" });
  }
}

async function getAdmin(req, res) {
  try {
    const data = await adminService.getAdminById(req.params.id);
    if (!data)
      return send(res, 404, { success: false, message: "Admin not found" });
    return send(res, 200, { success: true, message: "Success", data });
  } catch (err) {
    logger.error("getAdmin error: %o", err);
    return send(res, 500, { success: false, message: "Error fetching admin" });
  }
}

async function login(req, res) {
  try {
    const { error, value } = loginSchema.validate(req.body);
    if (error)
      return res.status(400).json({ success: false, message: error.message });

    const result = await adminService.login(value.mobile, value.password);
    if (!result)
      return res
        .status(401)
        .json({ success: false, message: "Invalid mobile or password" });

    // set secure cookie for refresh token (httpOnly)
    const refreshTokenPlain = result.refreshToken;
    const secureCookie = process.env.NODE_ENV === "production";

    res.cookie("RefreshToken", refreshTokenPlain, {
      httpOnly: true,
      secure: secureCookie,
      sameSite: secureCookie ? "None" : "Lax",
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
    });

    // return access token and minimal admin info
    return res.status(200).json({
      success: true,
      message: "Login successful",
      data: {
        accessToken: result.accessToken,
        admin: {
          id: result.admin._id,
          name: result.admin.name,
          email: result.admin.email,
          mobile: result.admin.mobile,
          designation: result.admin.designation,
          permissions: result.admin.permissions,
          superAdmin: result.admin.superAdmin,
        },
      },
    });
  } catch (err) {
    logger.error("login error: %o", err);
    return res.status(500).json({ success: false, message: "Login failed" });
  }
}

async function logout(req, res) {
  try {
    // prefer cookie, fallback to body/header
    const refreshPlain =
      req.cookies?.RefreshToken || req.body.refreshToken || null;
    if (!refreshPlain) {
      return res
        .status(400)
        .json({ success: false, message: "No refresh token provided" });
    }
    const admin = await adminService.logoutByRefreshToken(refreshPlain);
    if (!admin)
      return res.status(404).json({ success: false, message: "Invalid token" });

    // clear cookie
    res.clearCookie("RefreshToken");
    return res
      .status(200)
      .json({ success: true, message: "Logout successful" });
  } catch (err) {
    logger.error("logout error: %o", err);
    return res.status(500).json({ success: false, message: "Logout failed" });
  }
}

async function refreshAccessToken(req, res) {
  try {
    const refreshPlain = req.cookies?.RefreshToken || req.body.refreshToken;
    if (!refreshPlain)
      return res
        .status(400)
        .json({ success: false, message: "No refresh token" });

    const refreshHash = hashRefreshToken(refreshPlain);
    const admin = await adminService.findByRefreshTokenHash(refreshHash);
    if (!admin)
      return res
        .status(401)
        .json({ success: false, message: "Invalid refresh token" });

    // issue new access token and rotate refresh token
    const accessToken = require("../../utils/jwt.util").signAccessToken({
      id: admin._id,
      mobile: admin.mobile,
    });
    const newRefreshPlain =
      require("../../utils/jwt.util").generateRefreshTokenPlain();
    await adminService.rotateRefreshToken(admin._id, newRefreshPlain);

    res.cookie("RefreshToken", newRefreshPlain, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: process.env.NODE_ENV === "production" ? "None" : "Lax",
      maxAge: 30 * 24 * 60 * 60 * 1000,
    });

    return res.status(200).json({ success: true, data: { accessToken } });
  } catch (err) {
    logger.error("refreshAccessToken error: %o", err);
    return res
      .status(500)
      .json({ success: false, message: "Could not refresh token" });
  }
}

module.exports = {
  addAdmin,
  updateAdmin,
  deleteAdmin,
  listAdmins,
  getAdmin,
  login,
  logout,
  refreshAccessToken,
};
:
===== coachController.js ===== 
const coachService = require("../../services/coach/coachService");
const otpService = require("../../services/otpService");
const { encrypt, decrypt } = require("../../utils/cryptography.util");
const validateInputs = require("../../utils/validateInputs.util");
const { logError } = require("../../utils/errorLogger.util");
const path = require("path");

const COOKIE_REFRESH_NAME = "CoachRefreshToken";
const COOKIE_MAX_AGE = 24 * 60 * 60 * 1000 * 30; // ~30 days (cookie expiry mirrors refresh token expiry)
/**
 * Helper to set refresh token cookie
 */
function setRefreshCookie(res, refreshTokenPlain) {
  res.cookie(COOKIE_REFRESH_NAME, refreshTokenPlain, {
    httpOnly: true,
    maxAge: COOKIE_MAX_AGE,
    secure: process.env.COOKIE_SECURE === "true",
    sameSite: process.env.COOKIE_SAMESITE || "Lax",
  });
}

/**
 * Helper to clear refresh cookie
 */
function clearRefreshCookie(res) {
  res.clearCookie(COOKIE_REFRESH_NAME);
}

async function signup(req, res) {
  try {
    const {
      name,
      password,
      mobile,
      mobileVerified,
      agree_terms_conditions,
      agree_privacy_policy,
    } = req.body;

    if (!name || !password || !mobile) {
      return res.status(400).json({
        ok: false,
        message: "Please provide name, password, and mobile",
      });
    }

    if (!agree_terms_conditions || !agree_privacy_policy) {
      return res.status(400).json({
        ok: false,
        message: "You must agree to Terms & Conditions and Privacy Policy",
      });
    }

    const newCoach = await coachService.createUnverifiedCoach({
      name,
      password,
      mobile,
      mobileVerified,
      agree_terms_conditions,
      agree_privacy_policy,
    });

    // Do not auto-login on signup; return created coach and legacy token encrypted for interim flows
    const legacyToken = newCoach.token || null;
    const encryptedLegacyToken = legacyToken ? encrypt(legacyToken) : null;

    return res.status(201).json({
      ok: true,
      message: "Signup successful — verify OTP to finish signup",
      data: {
        id: newCoach._id,
        name: newCoach.name,
        mobile: newCoach.mobile,
        mobileVerified: newCoach.mobileVerified,
        agree_terms_conditions: newCoach.agree_terms_conditions,
        agree_privacy_policy: newCoach.agree_privacy_policy,
        legacyToken: encryptedLegacyToken,
      },
    });
  } catch (err) {
    await logError({
      name: "signup_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("signup error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function verifyOtp(req, res) {
  try {
    const { otp, otpId } = req.body;
    if (!otp || !otpId)
      return res
        .status(400)
        .json({ ok: false, message: "otp and otpId required" });

    const result = await otpService.verifyOtp(otpId, otp);
    if (!result.ok) {
      switch (result.reason) {
        case "expired":
          return res.status(410).json({ ok: false, message: "OTP expired" });
        case "max_attempts":
          return res
            .status(429)
            .json({ ok: false, message: "Max attempts exceeded" });
        default:
          return res.status(401).json({ ok: false, message: "Invalid OTP" });
      }
    }

    // Accept optional metadata (userAgent, ip) for refresh token record
    const reqMeta = { userAgent: req.get("User-Agent"), ip: req.ip };

    const { accessToken, refreshTokenPlain, coach } =
      await coachService.processOtpVerification(result.record, reqMeta);
    if (!coach)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    setRefreshCookie(res, refreshTokenPlain);

    return res.status(200).json({
      ok: true,
      message: "Verified and logged in",
      accessToken, // JWT - client should store in memory / Authorization header
      coach,
    });
  } catch (err) {
    await logError({
      name: "verifyOtp_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("verifyOtp error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function login(req, res) {
  try {
    const { mobile, password } = req.body;
    if (!mobile || !password)
      return res
        .status(400)
        .json({ ok: false, message: "Provide mobile and password" });

    const reqMeta = { userAgent: req.get("User-Agent"), ip: req.ip };
    const result = await coachService.login(mobile, password, reqMeta);
    if (!result)
      return res
        .status(401)
        .json({ ok: false, message: "Invalid mobile or password" });

    setRefreshCookie(res, result.refreshTokenPlain);

    return res.status(200).json({
      ok: true,
      message: "Login successful",
      accessToken: result.accessToken,
      coach: result.coach,
    });
  } catch (err) {
    await logError({
      name: "login_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("login error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

/**
 * Refresh endpoint
 * Reads refresh token from cookie (CoachRefreshToken) or body.refreshToken
 * If valid, rotates refresh token and returns a new access token (and sets new refresh cookie).
 */
async function refreshToken(req, res) {
  try {
    const refreshTokenPlain =
      req.cookies?.[COOKIE_REFRESH_NAME] || req.body?.refreshToken;
    if (!refreshTokenPlain)
      return res
        .status(401)
        .json({ ok: false, message: "No refresh token provided" });

    const reqMeta = { userAgent: req.get("User-Agent"), ip: req.ip };
    const refreshed = await coachService.refreshAccessToken(
      refreshTokenPlain,
      reqMeta
    );
    if (!refreshed.ok) {
      // Clear cookie if invalid / expired
      clearRefreshCookie(res);
      return res
        .status(401)
        .json({ ok: false, message: "Invalid or expired refresh token" });
    }

    // If rotated a new refresh token, set it as cookie
    if (refreshed.refreshTokenPlain)
      setRefreshCookie(res, refreshed.refreshTokenPlain);

    return res.status(200).json({
      ok: true,
      accessToken: refreshed.accessToken,
      coach: refreshed.coach,
    });
  } catch (err) {
    await logError({
      name: "refreshToken_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("refreshToken error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function logout(req, res) {
  try {
    // try to read refresh token cookie to revoke
    const refreshTokenPlain =
      req.cookies?.[COOKIE_REFRESH_NAME] || req.body?.refreshToken;
    const coachId = req.coach?._id || null;

    // if refresh token provided, revoke only that one; else if coachId present => clear all
    const ok = await coachService.logout(refreshTokenPlain, coachId);
    clearRefreshCookie(res);
    return res.status(200).json({ ok: true, message: "Logout successful" });
  } catch (err) {
    await logError({
      name: "logout_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("logout error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

/* --- checkCookie now validates access JWT (if provided) and returns coach info --- */
async function checkCookie(req, res) {
  try {
    // Accept Authorization: Bearer <token> OR cookie 'accessToken' OR we can try refresh flow
    const authHeader = req.headers.authorization;
    const accessFromHeader =
      (authHeader && authHeader.split && authHeader.split(" ")[1]) || null;
    // fallback to refresh flow: exchange refresh token for access token
    if (!accessFromHeader) {
      // try cookie refresh
      const refreshTokenPlain = req.cookies?.[COOKIE_REFRESH_NAME];
      if (!refreshTokenPlain)
        return res
          .status(401)
          .json({ ok: false, message: "No token provided" });
      const refreshed = await coachService.refreshAccessToken(
        refreshTokenPlain,
        { userAgent: req.get("User-Agent"), ip: req.ip }
      );
      if (!refreshed.ok) {
        clearRefreshCookie(res);
        return res.status(401).json({ ok: false, message: "Invalid tokens" });
      }
      if (refreshed.refreshTokenPlain)
        setRefreshCookie(res, refreshed.refreshTokenPlain);
      return res.status(200).json({
        ok: true,
        message: "Token verified",
        accessToken: refreshed.accessToken,
        coach: refreshed.coach,
      });
    }

    // If access token provided, simply verify and return coach info
    const accessToken = accessFromHeader;
    // We'll rely on the verifyCoach middleware in typical flows; here we just show an endpoint that can validate tokens via middleware elsewhere.
    // For simplicity, call verify middleware logic by decoding and fetching coach
    const { verifyAccessToken } = require("../../utils/jwt.util");
    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !decoded.sub)
      return res
        .status(401)
        .json({ ok: false, message: "Invalid access token" });

    const coach = await coachService.getCoachById(decoded.sub);
    if (!coach)
      return res.status(401).json({ ok: false, message: "Coach not found" });

    return res
      .status(200)
      .json({ ok: true, message: "Token verified", accessToken, coach });
  } catch (err) {
    await logError({
      name: "checkCookie_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("checkCookie error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

/* ---------- Remaining controller functions are unchanged and will continue to use coachService ---------- */
/* ... keep the rest of your controller functions (getPersonalInfo, updateProfile, uploadCertificates, etc.) as they were.
   For brevity I will include them below unchanged — they still work because verifyCoach middleware sets req.coach. */

async function getPersonalInfo(req, res) {
  try {
    const coach = req.coach;
    if (!coach)
      return res.status(401).json({ ok: false, message: "Unauthorized" });

    const coachInfo = await coachService.getCoachById(coach._id);
    if (!coachInfo)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res
      .status(200)
      .json({ ok: true, message: "Personal info found", data: coachInfo });
  } catch (err) {
    await logError({
      name: "getPersonalInfo_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("getPersonalInfo error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function updateProfile(req, res) {
  try {
    const coachId = req.coach?._id || req.params.id;
    const updated = await coachService.updateCoach(coachId, req.body);
    if (!updated)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res.status(200).json({
      ok: true,
      message: "Profile updated successfully",
      data: updated,
    });
  } catch (err) {
    await logError({
      name: "updateProfile_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("updateProfile error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function changeStatus(req, res) {
  try {
    const { id } = req.params;
    const { status } = req.body;
    const updated = await coachService.changeCoachStatus(id, status);
    if (!updated)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res
      .status(200)
      .json({ ok: true, message: "Status updated", data: updated });
  } catch (err) {
    await logError({
      name: "changeStatus_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("changeStatus error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function blockUnblockCoach(req, res) {
  try {
    const { id } = req.params;
    const { isBlocked } = req.body;
    if (typeof isBlocked !== "boolean")
      return res
        .status(400)
        .json({ ok: false, message: "isBlocked must be boolean" });

    const updated = await coachService.toggleBlockStatus(id, isBlocked);
    if (!updated)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res.status(200).json({
      ok: true,
      message: isBlocked
        ? "Coach blocked successfully"
        : "Coach unblocked successfully",
      data: updated,
    });
  } catch (err) {
    await logError({
      name: "blockUnblockCoach_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("blockUnblockCoach error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

/**
 * Upload / update / delete a certificate
 * - form-data: file (single, optional), certificateId (optional)
 * - If certificateId + file => update that certificate subdoc (replace file on disk)
 * - If certificateId + no file => delete certificate subdoc + disk file
 * - If no certificateId + file => create new certificate subdoc for the coach
 */
async function uploadCertificates(req, res) {
  try {
    const coachId = req.coach?._id;
    if (!coachId)
      return res.status(401).json({ ok: false, message: "Unauthorized" });

    // Allow certificateId to be passed either as form field 'certificateId' or body
    const certificateId = req.body.certificateId || req.body.id || null;
    const file = req.file || null; // single file upload 'file'
    const result = await coachService.uploadCertificateSingle(
      coachId,
      certificateId,
      file
    );

    return res.status(200).json({
      ok: true,
      message: result.message,
      data: result.data,
    });
  } catch (err) {
    await logError({
      name: "uploadCertificates_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("uploadCertificates error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function saveAgreement(req, res) {
  try {
    const coachId = req.coach?._id || req.body.coachId;
    const { title, content } = req.body;
    const updated = await coachService.saveAgreement(
      coachId,
      title,
      content || []
    );
    return res
      .status(200)
      .json({ ok: true, message: "Agreement saved", data: updated });
  } catch (err) {
    await logError({
      name: "saveAgreement_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("saveAgreement error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function savePricingSlots(req, res) {
  try {
    const coachId = req.coach?._id || req.body.coachId;
    const { categoryId, sessionKey, level, payload } = req.body;
    const updated = await coachService.saveSessionSlots(
      coachId,
      categoryId,
      sessionKey,
      level,
      payload
    );
    return res
      .status(200)
      .json({ ok: true, message: "Pricing slots saved", data: updated });
  } catch (err) {
    await logError({
      name: "savePricingSlots_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("savePricingSlots error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

/* List/get/like/dislike/save/unsave unchanged but wrapped with logError on exceptions for consistency */
const list = async (req, res) => {
  try {
    const { page, limit, status, q } = req.query;
    const docs = await coachService.listCoaches({
      page: parseInt(page) || 1,
      limit: parseInt(limit) || 20,
      status,
      q,
    });
    return res
      .status(200)
      .json({ ok: true, message: "Coaches fetched", data: docs });
  } catch (err) {
    await logError({
      name: "list_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("list error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

const getById = async (req, res) => {
  try {
    const coach = await coachService.getCoachById(req.params.id);
    if (!coach)
      return res.status(404).json({ ok: false, message: "Coach not found" });
    return res
      .status(200)
      .json({ ok: true, message: "Coach fetched", data: coach });
  } catch (err) {
    await logError({
      name: "getById_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("getById error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

const likeActivity = async (req, res) => {
  try {
    const coachId = req.coach?._id;
    const { id } = req.body;
    const updated = await coachService.toggleLikeActivity(coachId, id, "add");
    return res.status(200).json({
      ok: true,
      message: "Activity liked",
      data: updated.liked_activities,
    });
  } catch (err) {
    await logError({
      name: "likeActivity_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("likeActivity error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

const dislikeActivity = async (req, res) => {
  try {
    const coachId = req.coach?._id;
    const { id } = req.body;
    const updated = await coachService.toggleLikeActivity(
      coachId,
      id,
      "remove"
    );
    return res.status(200).json({
      ok: true,
      message: "Activity disliked",
      data: updated.liked_activities,
    });
  } catch (err) {
    await logError({
      name: "dislikeActivity_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("dislikeActivity error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

const saveCoach = async (req, res) => {
  try {
    const coachId = req.coach?._id;
    const { id } = req.body;
    const updated = await coachService.toggleSaveCoach(coachId, id, "add");
    return res
      .status(200)
      .json({ ok: true, message: "Coach saved", data: updated.saved_coaches });
  } catch (err) {
    await logError({
      name: "saveCoach_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("saveCoach error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

const unsaveCoach = async (req, res) => {
  try {
    const coachId = req.coach?._id;
    const { id } = req.body;
    const updated = await coachService.toggleSaveCoach(coachId, id, "remove");
    return res.status(200).json({
      ok: true,
      message: "Coach unsaved",
      data: updated.saved_coaches,
    });
  } catch (err) {
    await logError({
      name: "unsaveCoach_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("unsaveCoach error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

/**
 * Upload or update profile picture
 * - This expects req.file (single) and uses req.coach._id
 * - If req.file present: replace profile picture (delete old file)
 */
async function uploadProfilePicture(req, res) {
  try {
    const coachId = req.coach?._id;
    if (!coachId)
      return res.status(401).json({ ok: false, message: "Unauthorized" });

    const file = req.file || null;
    if (!file) {
      return res.status(400).json({ ok: false, message: "file required" });
    }

    const updated = await coachService.setProfilePicture(
      coachId,
      file.path || file.filename
    );
    if (!updated)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res.status(200).json({
      ok: true,
      message: "Profile picture uploaded",
      data: updated.profilePicture,
    });
  } catch (err) {
    await logError({
      name: "uploadProfilePicture_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("uploadProfilePicture error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

/**
 * Upload / update / delete a work asset
 * - form-data: file (single, optional), assetId (optional)
 * - If assetId + file => update existing asset
 * - If assetId + no file => delete existing asset
 * - If no assetId + file => create new asset
 */
async function uploadWorkAssets(req, res) {
  try {
    const coachId = req.coach?._id;
    if (!coachId)
      return res.status(401).json({ ok: false, message: "Unauthorized" });

    const assetId = req.body.assetId || req.body.id || null;
    const file = req.file || null;
    const result = await coachService.uploadWorkAssetSingle(
      coachId,
      assetId,
      file
    );

    return res.status(200).json({
      ok: true,
      message: result.message,
      data: result.data,
    });
  } catch (err) {
    await logError({
      name: "uploadWorkAssets_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      section: "coach",
      priority: "high",
    });
    console.error("uploadWorkAssets error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function checkCookie(req, res) {
  try {
    const rawToken =
      req.headers.token ||
      req.cookies?.[COOKIE_NAME] ||
      (req.headers.authorization && req.headers.authorization.split(" ")[1]);

    if (!rawToken)
      return res
        .status(401)
        .json({ ok: false, message: "Unauthorized: No token provided" });

    let token = decrypt(rawToken) || rawToken;

    const coach = await coachService.getCoachByToken(token);
    if (!coach)
      return res
        .status(401)
        .json({ ok: false, message: "Unauthorized: Coach not found" });

    // refresh cookie
    res.cookie(COOKIE_NAME, encrypt(token), {
      httpOnly: true,
      maxAge: COOKIE_MAX_AGE,
      secure: process.env.COOKIE_SECURE === "true",
      sameSite: process.env.COOKIE_SAMESITE || "Lax",
    });

    return res.status(200).json({
      ok: true,
      message: "Token verified",
      token: encrypt(token),
      coach,
    });
  } catch (err) {
    await logError({
      name: "checkCookie_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("checkCookie error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function coachProfileSetup(req, res) {
  try {
    const payload = { ...req.body, id: req.body.id };
    if (!payload.id)
      return res.status(400).json({ ok: false, message: "id is required" });

    const updatedCoach = await coachService.coachProfileSetupService(payload);
    if (!updatedCoach)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res.status(200).json({
      ok: true,
      message: "Profile updated successfully",
      data: updatedCoach,
    });
  } catch (err) {
    await logError({
      name: "coachProfileSetup_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("coachProfileSetup error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function saveStory(req, res) {
  try {
    const { id, story } = req.body;
    if (!id || !story)
      return res
        .status(400)
        .json({ ok: false, message: "Id and story required" });

    const savedStory = await coachService.saveStoryService({ id, story });
    if (!savedStory)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res.status(200).json({
      ok: true,
      message: "Story saved",
      data: { story: savedStory.story },
    });
  } catch (err) {
    await logError({
      name: "saveStory_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("saveStory error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

async function coachAgreementTerms(req, res) {
  try {
    const { id, agreement_terms } = req.body;
    if (!validateInputs(id))
      return res
        .status(400)
        .json({ ok: false, message: "Coach ID is required" });
    if (!validateInputs(agreement_terms))
      return res
        .status(400)
        .json({ ok: false, message: "Agreement terms required" });

    const coachAgreement = await coachService.coachAgreementTermsService({
      id,
      agreement_terms,
    });
    if (!coachAgreement)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res.status(200).json({
      ok: true,
      message: "Agreement terms updated",
      data: { agreement_terms: coachAgreement.agreement_terms },
    });
  } catch (err) {
    await logError({
      name: "coachAgreementTerms_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("coachAgreementTerms error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
}

const deleteCoach = async (req, res) => {
  try {
    const deletedCoach = await coachService.deleteCoach(req.params.id);
    if (!deletedCoach)
      return res.status(404).json({ ok: false, message: "Coach not found" });

    return res.status(200).json({
      ok: true,
      message: "Coach deleted successfully",
      data: deletedCoach,
    });
  } catch (err) {
    await logError({
      name: "deleteCoach_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("deleteCoach error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

const updatePassword = async (req, res) => {
  try {
    const { oldPassword, newPassword } = req.body;
    if (!oldPassword || !newPassword)
      return res
        .status(400)
        .json({ ok: false, message: "Old and new password required" });

    const result = await coachService.updatePassword(
      req.params.id,
      oldPassword,
      newPassword
    );
    if (!result)
      return res.status(404).json({ ok: false, message: "Coach not found" });
    if (result.error)
      return res.status(401).json({ ok: false, message: result.error });

    return res
      .status(200)
      .json({ ok: true, message: "Password updated successfully" });
  } catch (err) {
    await logError({
      name: "updatePassword_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "high",
    });
    console.error("updatePassword error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

const checkMobileAvailability = async (req, res) => {
  try {
    const { mobile } = req.body;
    if (!mobile)
      return res
        .status(400)
        .json({ ok: false, message: "Mobile number is required" });
    const available = await coachService.isMobileAvailable(mobile);
    return res.status(200).json({
      ok: true,
      message: available ? "Mobile available" : "Mobile already registered",
      available,
    });
  } catch (err) {
    await logError({
      name: "checkMobileAvailability_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "medium",
    });
    console.error("checkMobileAvailability error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

const forgetPassword = async (req, res) => {
  try {
    const { mobile, newPassword } = req.body;
    if (!mobile || !newPassword)
      return res
        .status(400)
        .json({ ok: false, message: "Mobile and new password required" });
    if (newPassword.length < 6)
      return res
        .status(400)
        .json({ ok: false, message: "Password must be at least 6 characters" });

    const updatedCoach = await coachService.forgetPasswordService(
      mobile,
      newPassword
    );
    if (!updatedCoach)
      return res
        .status(404)
        .json({ ok: false, message: "Coach not found with this mobile" });

    return res
      .status(200)
      .json({ ok: true, message: "Password updated successfully" });
  } catch (err) {
    await logError({
      name: "forgetPassword_exception",
      file: "controllers/coach/coachController.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "coach",
      priority: "medium",
    });
    console.error("forgetPassword error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal Server Error" });
  }
};

module.exports = {
  signup,
  coachProfileSetup,
  saveStory,
  coachAgreementTerms,
  verifyOtp,
  login,
  refreshToken,
  logout,
  getPersonalInfo,
  updateProfile,
  changeStatus,
  blockUnblockCoach,
  saveAgreement,
  savePricingSlots,
  list,
  getById,
  likeActivity,
  dislikeActivity,
  saveCoach,
  unsaveCoach,
  uploadProfilePicture,
  uploadCertificates,
  uploadWorkAssets,
  checkCookie,
  deleteCoach,
  updatePassword,
  checkMobileAvailability,
  forgetPassword,
};
:
===== otpMiddleware.js ===== 
const { decrypt } = require("../utils/cryptography.util");
const OtpRequest = require("../models/otpModel");
const { logError } = require("../utils/errorLogger.util");

/**
 * validateOtpId middleware:
 * - expects req.body.otpId (encrypted) to exist
 * - decodes and ensures record exists and attaches it to req.otpRecord
 * - optionally, if req.body.userType provided, verifies it matches the record's userType
 */
async function validateOtpId(req, res, next) {
  try {
    const { otpId, userType } = req.body;
    if (!otpId) {
      await logError({
        name: "validateOtpId_missing",
        file: "middlewares/otpMiddleware.js",
        description: "otpId missing from request body",
        section: "otp",
        priority: "low",
      });
      return res.status(400).json({ ok: false, message: "otpId required" });
    }

    const rawId = decrypt(otpId);
    if (!rawId) {
      await logError({
        name: "validateOtpId_decrypt_failed",
        file: "middlewares/otpMiddleware.js",
        description: "Invalid otpId - decrypt failed or null",
        section: "otp",
        priority: "medium",
      });
      return res.status(400).json({ ok: false, message: "Invalid otpId" });
    }

    const record = await OtpRequest.findOne({ otpId: rawId });
    if (!record) {
      await logError({
        name: "validateOtpId_not_found",
        file: "middlewares/otpMiddleware.js",
        description: `OTP request not found for otpId: ${String(rawId).slice(
          0,
          60
        )}`,
        section: "otp",
        priority: "medium",
      });
      return res
        .status(404)
        .json({ ok: false, message: "OTP request not found" });
    }

    if (userType && record.userType !== userType) {
      await logError({
        name: "validateOtpId_userType_mismatch",
        file: "middlewares/otpMiddleware.js",
        description: `otpId userType mismatch. expected ${userType} got ${record.userType}`,
        section: "otp",
        priority: "low",
      });
      return res
        .status(400)
        .json({ ok: false, message: "otpId does not match userType" });
    }

    req.otpRecord = record;
    next();
  } catch (err) {
    // Log full exception with stack
    await logError({
      name: "validateOtpId_exception",
      file: "middlewares/otpMiddleware.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "otp",
      priority: "high",
    });
    console.error("validateOtpId error:", err);
    return res
      .status(500)
      .json({ ok: false, message: "Internal server error" });
  }
}

module.exports = { validateOtpId };
:
===== auth.middleware.js ===== 
const { verifyAccessToken } = require("../../utils/jwt.util");
const Admin = require("../../models/admin/adminModel");
const logger = require("../../utils/logger");

/**
 * protect(requiredPermissions)
 * - requiredPermissions can be array of strings or a single string
 * - If not provided, just ensures valid token
 */
function protect(requiredPermissions) {
  return async function (req, res, next) {
    try {
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return res
          .status(401)
          .json({ success: false, message: "Unauthorized" });
      }

      const token = authHeader.split(" ")[1];
      const payload = verifyAccessToken(token);
      if (!payload || !payload.id) {
        return res
          .status(401)
          .json({ success: false, message: "Invalid or expired token" });
      }

      const admin = await Admin.findById(payload.id).select(
        "-password -refreshTokenHash"
      );
      if (!admin)
        return res
          .status(401)
          .json({ success: false, message: "Unauthorized" });

      req.admin = admin;

      // superAdmin bypass
      if (admin.superAdmin) return next();

      // If no requiredPermissions specified, allow
      if (!requiredPermissions) return next();

      const permsArray = Array.isArray(requiredPermissions)
        ? requiredPermissions
        : [requiredPermissions];

      // admin.permissions expected to be array
      const has = permsArray.some(
        (p) => admin.permissions && admin.permissions.includes(p)
      );
      if (!has) {
        return res.status(403).json({
          success: false,
          message: `Permission denied. One of [${permsArray.join(
            ", "
          )}] required`,
        });
      }

      next();
    } catch (err) {
      logger.error("Auth middleware error: %o", err);
      return res
        .status(500)
        .json({ success: false, message: "Internal server error" });
    }
  };
}

module.exports = protect;
:
===== verifyCoach.js ===== 
const { verifyAccessToken } = require("../../utils/jwt.util");
const Coach = require("../../models/coach/coachModel");
const { logError } = require("../../utils/errorLogger.util");

/**
 * options: { allowStatuses: ['verified','pending'] }
 * This middleware expects an Authorization: Bearer <accessToken> header.
 * If you want to allow using refresh cookie to obtain an access token, call refresh endpoint first.
 */
const verifyCoach = (options = {}) => {
  return async (req, res, next) => {
    try {
      const authHeader = req.headers.authorization;
      const accessToken =
        authHeader && authHeader.split ? authHeader.split(" ")[1] : null;

      if (!accessToken) {
        return res
          .status(403)
          .json({ ok: false, message: "Unauthorized: No access token" });
      }

      const decoded = verifyAccessToken(accessToken);
      if (!decoded || !decoded.sub) {
        return res
          .status(403)
          .json({ ok: false, message: "Unauthorized: Invalid access token" });
      }

      const coach = await Coach.findById(decoded.sub).lean();
      if (!coach) {
        await logError({
          name: "verifyCoach_not_found",
          file: "middlewares/coach/verifyCoach.js",
          description: "Token sub not matched to any coach",
          section: "coach",
          priority: "medium",
        });
        return res
          .status(403)
          .json({ ok: false, message: "Unauthorized: Coach not found" });
      }

      if (coach.isBlocked) {
        return res.status(403).json({ ok: false, message: "Account blocked" });
      }

      if (options.allowStatuses && Array.isArray(options.allowStatuses)) {
        if (!options.allowStatuses.includes(coach.status))
          return res
            .status(403)
            .json({ ok: false, message: "Insufficient status" });
      }

      req.coach = coach;
      next();
    } catch (err) {
      await logError({
        name: "verifyCoach_exception",
        file: "middlewares/coach/verifyCoach.js",
        description: err && err.message ? err.message : String(err),
        stack: err && err.stack ? err.stack : undefined,
        section: "coach",
        priority: "high",
      });
      console.error("verifyCoach error:", err);
      res.status(500).json({ ok: false, message: "Internal server error" });
    }
  };
};

module.exports = verifyCoach;
:
===== errorModel.js ===== 
const mongoose = require("mongoose");

const ErrorSchema = new mongoose.Schema({
  name: { type: String },
  file: { type: String, required: true },
  description: { type: String, required: true }, // sanitized string message
  stack: { type: String },
  dateTime: { type: Date, required: true, default: Date.now },
  section: { type: String },
  priority: { type: String, enum: ["low", "medium", "high"], default: "low" },
});

module.exports = mongoose.model("Error", ErrorSchema);
:
===== otpModel.js ===== 
const mongoose = require("mongoose");
const { Schema } = mongoose;

const OtpSchema = new Schema(
  {
    phone: { type: String, required: true, index: true },
    userType: {
      type: String,
      required: true,
      enum: ["client", "coach", "eventOrganizer", "productCompany"],
      index: true,
    },
    operation: {
      type: String,
      required: false,
      // examples: "login", "register", "reset-password", "transaction"
      index: true,
    },
    otpEncrypted: { type: String }, // optional if using provider-only
    otpId: { type: String, required: true, unique: true }, // raw otpId stored; we return encrypted to client
    attempts: { type: Number, default: 0 },
    maxAttempts: { type: Number, default: 5 },
    verified: { type: Boolean, default: false },
    expiresAt: { type: Date, required: true, index: true }, // TTL index below
    lastSentAt: { type: Date, default: Date.now }, // for throttling/resend
    resendCount: { type: Number, default: 0 }, // useful for rate limiting
    provider: {
      type: String,
      enum: ["twilio", "twilio-sms", "local"],
      default: "local",
    },
    meta: { type: Schema.Types.Mixed },
  },
  { timestamps: true }
);

// TTL index to remove doc when expiresAt reached
OtpSchema.index({ expiresAt: 1 }, { expireAfterSeconds: 0 });

// useful compound index for queries
OtpSchema.index({ phone: 1, userType: 1, verified: 1, expiresAt: 1 });

module.exports = mongoose.model("OtpRequest", OtpSchema);
:
===== activitiesModel.js ===== 
// models/activities/activitiesModel.js
const mongoose = require("mongoose");

const ActivitySchema = new mongoose.Schema(
  {
    layer: { type: Number, required: true }, // 1 (root) or 2 (child)
    title: { type: String, required: true },
    parent_id: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Activity",
      required: false,
    },
    contains_subtopic: { type: Boolean, required: true, default: false },
  },
  { timestamps: true }
);

const Activity =
  mongoose.models.Activity || mongoose.model("Activity", ActivitySchema);
module.exports = Activity;
:
===== adminModel.js ===== 
const mongoose = require("mongoose");

const AdminSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    email: { type: String, unique: true, sparse: true },
    mobile: { type: String, required: true, unique: true },
    password: { type: String, required: true }, // bcrypt hash
    dob: { type: Date },
    country: { type: String },
    gender: { type: String },
    profilePicture: { type: String },
    // We'll store hashed refresh token for rotation/invalidation
    refreshTokenHash: { type: String },
    designation: { type: String },
    permissions: [{ type: String }], // not required: superAdmin can have empty array
    superAdmin: { type: Boolean, default: false },
    createdBy: { type: mongoose.Schema.Types.ObjectId, ref: "Admin" },
    updatedBy: { type: mongoose.Schema.Types.ObjectId, ref: "Admin" },
    lastLoginAt: { type: Date },
  },
  { timestamps: true }
);

module.exports = mongoose.model("Admin", AdminSchema);
:
===== coachModel.js ===== 
// models/coach/coachModel.js
const mongoose = require("mongoose");

const RefreshTokenSchema = new mongoose.Schema({
  tokenHash: { type: String, required: true },
  expiresAt: { type: Date, required: true },
  createdAt: { type: Date, default: Date.now },
  userAgent: { type: String },
  ip: { type: String },
});

const CertificateSchema = new mongoose.Schema(
  {
    path: { type: String, required: true }, // stored as relative path or full public url
  },
  { timestamps: true }
);

const WorkAssetSchema = new mongoose.Schema(
  {
    type: { type: String, enum: ["image", "video"], required: true },
    path: { type: String, required: true },
  },
  { timestamps: true }
);

const CoachSchema = new mongoose.Schema(
  {
    name: { type: String, required: true, index: true },
    email: { type: String, index: true, sparse: true },
    nick_name: { type: String },
    mobile: { type: String, unique: true, required: true, index: true },
    password: { type: String, required: true },
    dob: { type: Date },
    country: { type: String },
    gender: { type: String },
    city: { type: String },
    address: { type: String },
    pincode: { type: Number },

    profilePicture: { type: String }, // stored as relative path (not full URL)
    certificates: [CertificateSchema],
    workAssets: [WorkAssetSchema],

    // legacy random token (kept for compatibility)
    token: { type: String, index: true },

    // JWT / refresh-token based fields
    refreshTokens: [RefreshTokenSchema], // holds hashed refresh tokens

    status: {
      type: String,
      enum: ["unverified", "pending", "verified", "deleted", "blocked"],
      default: "unverified",
    },
    isBlocked: { type: Boolean, default: false },
    mobileVerified: { type: Boolean, default: false },

    my_activities: [String],
    accepted_genders: [String],
    accepted_languages: [String],

    experience_since_date: { type: Date },
    cue_share_percentage: { type: Number },
    coach_share_percentage: { type: Number },
    story: { type: String },

    agreement_terms: { type: mongoose.Schema.Types.Mixed },

    saved_coaches: [String],
    liked_activities: [String],

    has_read_awareness_guideline: { type: Boolean, default: false },

    agree_terms_conditions: { type: Boolean, required: true },
    agree_privacy_policy: { type: Boolean, required: true },

    agree_certification: { type: Boolean, default: false },
    agree_experience: { type: Boolean, default: false },
    agree_refund: { type: Boolean, default: false },
  },
  { timestamps: true }
);

// Compound indexes for common queries
CoachSchema.index({ mobile: 1 });
CoachSchema.index({ token: 1 });
CoachSchema.index({ status: 1 });

module.exports = mongoose.model("Coach", CoachSchema);
:
===== otpRoutes.js ===== 
// routes/otpRoutes.js
const express = require("express");
const router = express.Router();
const otpController = require("../controllers/otpController");
const { validateOtpId } = require("../middlewares/otpMiddleware");

// Public: send OTP (requires phone + userType)
router.post("/send", otpController.sendOtp);

// Public: verify OTP
router.post("/verify", otpController.verifyOtp);

// Public: resend OTP (requires otpId)
router.post("/resend", validateOtpId, otpController.resendOtp);

module.exports = router;
:
===== activitiesRoute.js ===== 
// routes/activities/activitiesRoutes.js
const express = require("express");
const router = express.Router();
const activityController = require("../../controllers/activities/activitiesController");
const verifyAdmin = require("../../middlewares/admin/auth.middleware");
const permissions = require("../../configs/permissionConfig");

// Public: view roots or children
router.get("/", activityController.listActivities);

// Admin protected: add (single API will create root or sub depending on parent_id)
router.post("/add", verifyAdmin(permissions["admin:add"]), activityController.addActivityOrSubActivity);

// Admin protected: update title
router.put("/update/:id", verifyAdmin(permissions["admin:update"]), activityController.updateActivity);

// Admin protected: delete
router.delete("/delete/:id", verifyAdmin(permissions["admin:delete"]), activityController.deleteActivity);

module.exports = router;
:
===== adminRoutes.js ===== 
const express = require("express");
const router = express.Router();
const adminController = require("../../controllers/admin/adminController");
const protect = require("../../middlewares/admin/auth.middleware");
const permissions = require("../../configs/permissionConfig");
const rateLimit = require("express-rate-limit");

// rate limiter for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: parseInt(process.env.AUTH_RATE_LIMIT || "10", 10),
  message: { success: false, message: "Too many requests, try again later" },
});

// public
router.post("/login", authLimiter, adminController.login);
router.post("/refresh", adminController.refreshAccessToken); // uses cookie or body refresh token
router.post("/logout", authLimiter, adminController.logout); // logout requires valid access token

// protected - admin management
router.post("/add", protect(permissions["admin:add"]), adminController.addAdmin);
router.get("/list", protect(permissions["admin:list"]), adminController.listAdmins);
router.get("/get/:id", protect(permissions["admin:get"]), adminController.getAdmin);
router.put("/update/:id", protect(permissions["admin:update"]), adminController.updateAdmin);
router.delete("/delete/:id", protect(permissions["admin:delete"]), adminController.deleteAdmin);

module.exports = router;
:
===== coachRoutes.js ===== 
// routes/coachRoutes.js
const express = require("express");
const router = express.Router();
const coachController = require("../../controllers/coach/coachController");
const verifyCoach = require("../../middlewares/coach/verifyCoach");
const verifyAdmin = require("../../middlewares/admin/auth.middleware");
const permissions = require("../../configs/permissionConfig");
const { profilePicUpload, certificateUpload, workAssetUpload } = require("../../configs/uploadConfig");

// Public
router.post("/signup", coachController.signup);
router.post("/verify-otp", coachController.verifyOtp);
router.post("/login", coachController.login);
router.post("/refresh-token", coachController.refreshToken);
router.post("/logout", verifyCoach(), coachController.logout);
router.post("/logout-all", verifyCoach(), async (req, res) => {
  try {
    const coachId = req.coach._id;
    await require("../../services/coach/coachService").clearAllRefreshTokens(coachId);
    res.clearCookie("CoachRefreshToken");
    return res.status(200).json({ ok: true, message: "Logged out from all devices" });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ ok: false, message: "Internal Server Error" });
  }
});
router.post("/check-cookie", coachController.checkCookie);
router.post("/check-mobile", coachController.checkMobileAvailability);
router.put("/forget-password", coachController.forgetPassword);

// Authenticated coach routes
router.get("/me", verifyCoach(), coachController.getPersonalInfo);
router.put("/me", verifyCoach(), coachController.updateProfile);
router.delete("/delete/:id", verifyCoach(), coachController.deleteCoach);
router.put("/updatePassword/:id", verifyCoach(), coachController.updatePassword);
router.patch("/profile-setup", verifyCoach(), coachController.coachProfileSetup);
router.patch("/story", verifyCoach(), coachController.saveStory);
router.patch("/agreement-terms", verifyCoach(), coachController.coachAgreementTerms);

// Uploads
// profile picture: unchanged single field 'profilePicture'
router.post("/upload/profile-picture", verifyCoach(), profilePicUpload.single("profilePicture"), coachController.uploadProfilePicture);

// certificates: single file per request. form-data fields: file, certificateId (optional), coachId (optional) - if coachId omitted, use req.coach._id
router.post("/upload/certificates", verifyCoach(), certificateUpload.single("file"), coachController.uploadCertificates);

// work assets: single file per request. form-data fields: file, assetId (optional)
router.patch("/upload/work-assets", verifyCoach(), workAssetUpload.single("file"), coachController.uploadWorkAssets);

// Like / save
router.post("/like-activity", verifyCoach(), coachController.likeActivity);
router.post("/dislike-activity", verifyCoach(), coachController.dislikeActivity);
router.post("/save-coach", verifyCoach(), coachController.saveCoach);
router.post("/unsave-coach", verifyCoach(), coachController.unsaveCoach);

// Admin-only action: change status
router.get("/admin/list", verifyAdmin(permissions["coach:list"]), coachController.list);
router.get("/admin/get/:id", verifyAdmin(permissions["coach:get"]), coachController.getById);
router.put("/admin/change-status/:id", verifyAdmin(permissions["coach:changeStatus"]), coachController.changeStatus);
router.put("/admin/is-block/:id", verifyAdmin(permissions["coach:changeStatus"]), coachController.blockUnblockCoach);

module.exports = router;
:
===== seedSuperAdmin.js ===== 
const mongoose = require("mongoose");
const bcrypt = require("bcrypt");
const Admin = require("../models/admin/adminModel");

const SALT_ROUNDS = parseInt(process.env.BCRYPT_SALT_ROUNDS || "12", 10);

async function connect() {
  const dbMode = process.env.DB_MODE || "local";
  let uri;

  if (dbMode === "remote") {
    uri = `mongodb://${process.env.REMOTE_DB_USER}:${process.env.REMOTE_DB_PASS}@${process.env.REMOTE_DB_IP}:27017/${process.env.REMOTE_DB_NAME}?authSource=admin`;
  } else {
    uri = process.env.MONGO_URI_LOCAL;
  }

  mongoose.connect(uri);

  const db = mongoose.connection;
  db.on("error", console.error.bind(console, "MongoDB connection error:"));
  db.once("open", () => {
    console.log(`✅ Connected to MongoDB (${dbMode})`);
  });
}

// ------------------- ask() must be defined before main() -------------------
function ask(question) {
  const rl = require("readline").createInterface({
    input: process.stdin,
    output: process.stdout,
  });
  return new Promise((resolve) =>
    rl.question(question, (ans) => {
      rl.close();
      resolve(ans.trim());
    })
  );
}

function askHidden(question) {
  return new Promise((resolve) => {
    const stdin = process.stdin;
    const stdout = process.stdout;
    stdout.write(question);
    stdin.resume();
    stdin.setRawMode(true);
    let password = "";
    function onData(ch) {
      ch = String(ch);
      if (ch === "\n" || ch === "\r" || ch === "\u0004") {
        stdin.removeListener("data", onData);
        stdin.setRawMode(false);
        stdout.write("\n");
        stdin.pause();
        resolve(password);
        return;
      }
      if (ch === "\u0003") process.exit(); // ctrl-c
      password += ch;
      stdout.write("*");
    }
    stdin.on("data", onData);
  });
}

async function main() {
  try {
    await connect();
    console.log("Connected to DB.");

    const name = process.env.SUPERADMIN_NAME || (await ask("Name: "));
    const mobile =
      process.env.SUPERADMIN_MOBILE ||
      (await ask("Mobile (with country code, e.g. +91...): "));
    const email =
      process.env.SUPERADMIN_EMAIL || (await ask("Email (optional): "));
    const password =
      process.env.SUPERADMIN_PASSWORD ||
      (await askHidden("Password (input hidden): "));

    if (!name || !mobile || !password) {
      console.error("name, mobile and password are required.");
      process.exit(1);
    }

    const existing = await Admin.findOne({ $or: [{ mobile }, { email }] });
    if (existing) {
      console.error(
        "An admin with that mobile or email already exists. Aborting."
      );
      console.log("Existing admin id:", existing._id.toString());
      process.exit(1);
    }

    const hash = await bcrypt.hash(password, SALT_ROUNDS);

    const admin = new Admin({
      name,
      mobile,
      email: email || undefined,
      password: hash,
      permissions: [],
      superAdmin: true,
      createdBy: null,
    });

    await admin.save();
    console.log("✅ Super admin created successfully.");
    console.log("Admin id:", admin._id.toString());
    process.exit(0);
  } catch (err) {
    console.error("Error creating super admin:", err);
    process.exit(1);
  }
}

main();

// export REMOTE_DB_USER=cuewellness
// export REMOTE_DB_PASS=Cuewellness00700
// export REMOTE_DB_IP=97.74.94.169
// export REMOTE_DB_NAME=cueWellness-stagging
// node src/scripts/seedSuperAdmin.js
// Connected to DB.
// Name: ✅ Connected to MongoDB (remote)
// Super Admin
// Mobile (with country code, e.g. +91...): +919999999999
// Email (optional): support@cuewellness.net
// Password (input hidden): Password@123
// ✅ Super admin created successfully.
// Admin id: 68dcec63971c3dc845e0a6e2:
===== otpService.js ===== 
const OtpRequest = require("../models/otpModel");
const { encrypt, decrypt } = require("../utils/cryptography.util");
const getId = require("../utils/getId.util");
const { logError } = require("../utils/errorLogger.util");

// Env / defaults
const {
  TWILIO_ACCOUNT_SID,
  TWILIO_AUTH_TOKEN,
  TWILIO_VERIFY_SERVICE_SID,
  TWILIO_PHONE_NUMBER,
  OTP_EXPIRE_MINUTES,
  OTP_MAX_ATTEMPTS,
  OTP_RESEND_INTERVAL_SECONDS,
  OTP_MAX_RESENDS,
} = process.env;

const DEFAULT_EXPIRE_MINUTES = parseInt(OTP_EXPIRE_MINUTES || "10", 10);
const DEFAULT_MAX_ATTEMPTS = parseInt(OTP_MAX_ATTEMPTS || "5", 10);
const DEFAULT_RESEND_INTERVAL_MS =
  parseInt(OTP_RESEND_INTERVAL_SECONDS || "30", 10) * 1000;
const DEFAULT_MAX_RESENDS = parseInt(OTP_MAX_RESENDS || "5", 10);

let client = null;
if (TWILIO_ACCOUNT_SID && TWILIO_AUTH_TOKEN) {
  const twilio = require("twilio");
  client = twilio(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN);
}

// helper to normalize phone (best-effort). For production use libphonenumber-js/E.164
function normalizePhone(phone) {
  if (!phone) return phone;
  const trimmed = phone.replace(/\s+/g, "");

  // Basic E.164 validation
  const e164 = /^\+[1-9]\d{6,14}$/;
  if (!e164.test(trimmed)) {
    throw new Error(`Invalid phone number format: ${trimmed}`);
  }

  return trimmed;
}

function generateOtp() {
  return Math.floor(100000 + Math.random() * 900000).toString();
}

/**
 * Create an OTP record and send OTP.
 * @param {string} phoneRaw
 * @param {object} opts - { userType: 'coach', meta: {}, operation: 'login' }
 * @returns {Object} { otpId: <encrypted> }
 */
async function createAndSendOtp(phoneRaw, opts = {}) {
  try {
    const phone = normalizePhone(phoneRaw);
    const { userType = "client", meta = {}, operation } = opts;

    if (!phone) throw new Error("Phone required");

    // throttle: check for very recent send
    const existingActive = await OtpRequest.findOne({
      phone,
      userType,
      verified: false,
      expiresAt: { $gt: new Date() },
    });

    if (existingActive) {
      const lastSent = existingActive.lastSentAt
        ? new Date(existingActive.lastSentAt).getTime()
        : 0;
      if (Date.now() - lastSent < DEFAULT_RESEND_INTERVAL_MS) {
        throw new Error("OTP just sent. Please wait a moment before retrying.");
      }
      // optional: we could reuse/update existingActive instead of creating new doc
    }

    const otpPlain = generateOtp();
    const otpId = getId(12);
    const expiresAt = new Date(Date.now() + DEFAULT_EXPIRE_MINUTES * 60 * 1000);

    const provider =
      client && TWILIO_VERIFY_SERVICE_SID
        ? "twilio"
        : client && TWILIO_PHONE_NUMBER
        ? "twilio-sms"
        : "local";

    const doc = new OtpRequest({
      phone,
      userType,
      operation: operation || undefined,
      otpEncrypted: provider === "local" ? encrypt(otpPlain) : undefined,
      otpId,
      maxAttempts: DEFAULT_MAX_ATTEMPTS,
      expiresAt,
      lastSentAt: new Date(),
      resendCount: 0,
      meta,
      provider,
    });

    await doc.save();

    // Send via provider or fallback to local SMS
    try {
      if (provider === "twilio" && client && TWILIO_VERIFY_SERVICE_SID) {
        await client.verify.v2
          .services(TWILIO_VERIFY_SERVICE_SID)
          .verifications.create({ to: phone, channel: "sms" });
      } else if (provider === "twilio-sms" && client && TWILIO_PHONE_NUMBER) {
        await client.messages.create({
          to: phone,
          from: TWILIO_PHONE_NUMBER,
          body: `Your verification code is ${otpPlain}`,
        });
      } else if (provider === "local") {
        // No SMS transport configured — keep record but inform caller
        // Log as error because OTP not delivered
        await logError({
          name: "otp_send_no_provider",
          file: "services/otpService.js",
          description: `No SMS provider configured; otpId=${String(otpId).slice(
            0,
            60
          )}`,
          section: "otp",
          priority: "high",
        });
        throw new Error("No SMS provider configured to send OTP");
      }
    } catch (err) {
      // If sending fails we delete the record to avoid orphaned unverified entries
      try {
        await OtpRequest.findByIdAndDelete(doc._id);
      } catch (e) {
        /* ignore */
      }

      await logError({
        name: "otp_send_failed",
        file: "services/otpService.js",
        description: err && err.message ? err.message : String(err),
        stack: err && err.stack ? err.stack : undefined,
        section: "otp",
        priority: "high",
      });

      throw new Error("Failed to send OTP: " + (err.message || String(err)));
    }

    return { otpId: encrypt(otpId) };
  } catch (err) {
    // Log unexpected errors
    await logError({
      name: "createAndSendOtp_exception",
      file: "services/otpService.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "otp",
      priority: "high",
    });
    throw err;
  }
}

/**
 * Verify OTP for encrypted otpId
 * @param {string} otpIdEncrypted
 * @param {string} otp
 */
async function verifyOtp(otpIdEncrypted, otp) {
  try {
    if (!otpIdEncrypted || !otp) throw new Error("otpId and otp required");

    const otpId = decrypt(otpIdEncrypted);
    if (!otpId) return { ok: false, reason: "invalid_otpId" };

    const record = await OtpRequest.findOne({ otpId });
    if (!record) return { ok: false, reason: "invalid_otpId" };
    if (record.verified) return { ok: false, reason: "already_verified" };
    if (record.expiresAt < new Date()) return { ok: false, reason: "expired" };
    if (record.attempts >= record.maxAttempts)
      return { ok: false, reason: "max_attempts" };

    // If Twilio verify used, delegate to provider
    if (record.provider === "twilio" && client && TWILIO_VERIFY_SERVICE_SID) {
      try {
        const verificationCheck = await client.verify.v2
          .services(TWILIO_VERIFY_SERVICE_SID)
          .verificationChecks.create({ to: record.phone, code: otp });

        if (verificationCheck.status === "approved") {
          record.verified = true;
          await record.save();
          return { ok: true, record };
        } else {
          record.attempts += 1;
          await record.save();
          return { ok: false, reason: "invalid_code" };
        }
      } catch (err) {
        record.attempts += 1;
        await record.save();

        await logError({
          name: "otp_verify_provider_error",
          file: "services/otpService.js",
          description: err && err.message ? err.message : String(err),
          stack: err && err.stack ? err.stack : undefined,
          section: "otp",
          priority: "high",
        });

        return { ok: false, reason: "invalid_code" };
      }
    }

    // Fallback: local decrypt and compare
    const storedOtp = decrypt(record.otpEncrypted);
    if (!storedOtp) {
      record.attempts += 1;
      await record.save();
      return { ok: false, reason: "invalid_code" };
    }

    if (storedOtp === otp) {
      record.verified = true;
      await record.save();
      return { ok: true, record };
    } else {
      record.attempts += 1;
      await record.save();
      return { ok: false, reason: "invalid_code" };
    }
  } catch (err) {
    await logError({
      name: "verifyOtp_exception",
      file: "services/otpService.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "otp",
      priority: "high",
    });
    throw err;
  }
}

/**
 * Resend OTP for provided encrypted otpId.
 * Keeps userType consistent. If expired -> create new record (preserving userType).
 */
async function resendOtp(otpIdEncrypted) {
  try {
    if (!otpIdEncrypted) throw new Error("otpId required");

    const otpId = decrypt(otpIdEncrypted);
    if (!otpId) return { ok: false, reason: "invalid_otpId" };

    const record = await OtpRequest.findOne({ otpId });
    if (!record) return { ok: false, reason: "invalid_otpId" };
    if (record.verified) return { ok: false, reason: "already_verified" };

    const lastSent = record.lastSentAt
      ? new Date(record.lastSentAt).getTime()
      : 0;
    if (Date.now() - lastSent < DEFAULT_RESEND_INTERVAL_MS) {
      return { ok: false, reason: "too_many_requests" };
    }
    if ((record.resendCount || 0) >= DEFAULT_MAX_RESENDS) {
      return { ok: false, reason: "resend_limit_reached" };
    }

    // if expired, create new OTP (preserving userType)
    if (record.expiresAt < new Date()) {
      return await createAndSendOtp(record.phone, {
        userType: record.userType,
        meta: record.meta,
        operation: record.operation,
      });
    }

    // otherwise update OTP in-place
    const newOtp = generateOtp();
    record.otpEncrypted =
      record.provider === "local" ? encrypt(newOtp) : record.otpEncrypted;
    record.attempts = 0;
    record.expiresAt = new Date(
      Date.now() + DEFAULT_EXPIRE_MINUTES * 60 * 1000
    );
    record.lastSentAt = new Date();
    record.resendCount = (record.resendCount || 0) + 1;
    await record.save();

    try {
      if (record.provider === "twilio" && client && TWILIO_VERIFY_SERVICE_SID) {
        // Twilio Verify will generate and send a new code
        await client.verify.v2
          .services(TWILIO_VERIFY_SERVICE_SID)
          .verifications.create({ to: record.phone, channel: "sms" });
      } else if (
        record.provider === "twilio-sms" &&
        client &&
        TWILIO_PHONE_NUMBER
      ) {
        await client.messages.create({
          to: record.phone,
          from: TWILIO_PHONE_NUMBER,
          body: `Your verification code is ${newOtp}`,
        });
      } else if (record.provider === "local") {
        await logError({
          name: "otp_resend_no_provider",
          file: "services/otpService.js",
          description: `No SMS provider configured for resend; otpId=${String(
            otpId
          ).slice(0, 60)}`,
          section: "otp",
          priority: "high",
        });
        throw new Error("No SMS provider configured to send OTP");
      } else {
        throw new Error("No SMS provider configured");
      }
    } catch (err) {
      await logError({
        name: "otp_resend_send_failed",
        file: "services/otpService.js",
        description: err && err.message ? err.message : String(err),
        stack: err && err.stack ? err.stack : undefined,
        section: "otp",
        priority: "high",
      });
      throw new Error("Failed to resend OTP: " + (err.message || String(err)));
    }

    return { ok: true };
  } catch (err) {
    await logError({
      name: "resendOtp_exception",
      file: "services/otpService.js",
      description: err && err.message ? err.message : String(err),
      stack: err && err.stack ? err.stack : undefined,
      section: "otp",
      priority: "high",
    });
    throw err;
  }
}

module.exports = {
  createAndSendOtp,
  verifyOtp,
  resendOtp,
};
:
===== activitiesService.js ===== 
// services/activities/activitiesService.js
const Activity = require("../../models/activities/activitiesModel");

/**
 * Add root activity
 */
async function addActivityService(title) {
  if (!title) throw new Error("title required");
  const exists = await Activity.findOne({
    title: { $regex: new RegExp(`^${title}$`, "i") },
    layer: 1,
  });
  if (exists) throw new Error("Activity already exists");
  const a = new Activity({ title, layer: 1, contains_subtopic: false });
  await a.save();
  return a;
}

/**
 * Add sub activity under parentId
 */
async function addSubActivity(parentId, title) {
  const parent = await Activity.findById(parentId);
  if (!parent) throw new Error("Parent activity not found");

  const exists = await Activity.findOne({
    title: { $regex: new RegExp(`^${title}$`, "i") },
    parent_id: parentId,
    layer: 2,
  });
  if (exists)
    throw new Error("This sub-activity already exists under the same parent");

  const subActivity = new Activity({
    layer: 2,
    title,
    parent_id: parentId,
    contains_subtopic: false,
  });

  // mark parent contains_subtopic
  if (!parent.contains_subtopic) {
    parent.contains_subtopic = true;
    await parent.save();
  }

  await subActivity.save();
  return subActivity;
}

/**
 * Add either root or sub depending on parent_id param
 */
async function addActivityOrSubActivity(title, parent_id) {
  if (parent_id) return addSubActivity(parent_id, title);
  return addActivityService(title);
}

/**
 * List root activities
 */
async function listRootActivities() {
  return Activity.find({ layer: 1 }).sort({ title: 1 }).lean();
}

/**
 * List children for a parent
 */
async function listChildren(parentId) {
  return Activity.find({ parent_id: parentId }).sort({ title: 1 }).lean();
}

/**
 * Update activity title by id
 */
async function updateActivity(id, title) {
  const updated = await Activity.findByIdAndUpdate(
    id,
    { $set: { title } },
    { new: true }
  );
  return updated;
}

/**
 * Delete activity and cascade delete children (if root)
 */
async function deleteActivity(id) {
  const doc = await Activity.findById(id);
  if (!doc) return null;

  if (doc.layer === 1) {
    // delete children
    await Activity.deleteMany({ parent_id: doc._id });
  }
  await Activity.findByIdAndDelete(id);

  // if the parent had siblings and now zero children remain, update parent contains_subtopic false
  if (doc.parent_id) {
    const siblings = await Activity.countDocuments({
      parent_id: doc.parent_id,
    });
    if (siblings === 0) {
      await Activity.findByIdAndUpdate(doc.parent_id, {
        $set: { contains_subtopic: false },
      });
    }
  }
  return true;
}

module.exports = {
  addActivityService,
  addSubActivity,
  addActivityOrSubActivity,
  listRootActivities,
  listChildren,
  updateActivity,
  deleteActivity,
};
:
===== adminService.js ===== 
const Admin = require("../../models/admin/adminModel");
const { hashPassword, comparePassword } = require("../../utils/password.util");
const {
  signAccessToken,
  generateRefreshTokenPlain,
  hashRefreshToken,
} = require("../../utils/jwt.util");
const logger = require("../../utils/logger");

// Create admin
async function createAdmin(data, createdById = null) {
  const passwordHash = await hashPassword(data.password);
  const newAdmin = new Admin({
    ...data,
    password: passwordHash,
    createdBy: createdById,
    // token fields left empty; will be set on login
  });
  await newAdmin.save();
  return newAdmin;
}

async function findAdminByMobile(mobile) {
  return Admin.findOne({ mobile });
}

async function checkAdminByMobileOrEmail(mobile, email) {
  const q = { $or: [] };
  if (mobile) q.$or.push({ mobile });
  if (email) q.$or.push({ email });
  if (q.$or.length === 0) return null;
  return Admin.findOne(q);
}

async function updateAdmin(adminId, updateData, updatedById = null) {
  const update = { ...updateData };
  if (update.password) {
    update.password = await hashPassword(update.password);
  }
  if (updatedById) update.updatedBy = updatedById;
  const updatedAdmin = await Admin.findByIdAndUpdate(adminId, update, {
    new: true,
    runValidators: true,
  }).select("-password -refreshTokenHash");
  return updatedAdmin;
}

async function deleteAdmin(adminId) {
  return Admin.findByIdAndDelete(adminId);
}

async function listAdmins({ page = 1, limit = 20 } = {}) {
  const skip = (parseInt(page, 10) - 1) * parseInt(limit, 10);
  const admins = await Admin.find()
    .select("-password -refreshTokenHash")
    .skip(skip)
    .limit(parseInt(limit, 10))
    .lean();
  return admins.map((a) => ({
    id: a._id,
    name: a.name,
    email: a.email,
    mobile: a.mobile,
    designation: a.designation,
    permissions: a.permissions,
    superAdmin: a.superAdmin,
    createdAt: a.createdAt,
    updatedAt: a.updatedAt,
  }));
}

async function getAdminById(id) {
  const admin = await Admin.findById(id).select("-password -refreshTokenHash");
  if (!admin) return null;
  return admin;
}

async function login(mobile, password) {
  const admin = await Admin.findOne({ mobile });
  if (!admin) return null;

  const ok = await comparePassword(password, admin.password);
  if (!ok) return null;

  // generate access + refresh tokens
  const accessToken = signAccessToken({ id: admin._id, mobile: admin.mobile });
  const refreshPlain = generateRefreshTokenPlain();
  const refreshHash = hashRefreshToken(refreshPlain);

  // store hashed refresh token and lastLogin
  admin.refreshTokenHash = refreshHash;
  admin.lastLoginAt = new Date();
  await admin.save();

  return {
    admin,
    accessToken,
    refreshToken: refreshPlain,
  };
}

async function rotateRefreshToken(adminId, newRefreshPlain) {
  const newHash = hashRefreshToken(newRefreshPlain);
  await Admin.findByIdAndUpdate(adminId, { refreshTokenHash: newHash });
}

async function logoutByRefreshToken(refreshPlain) {
  const hash = hashRefreshToken(refreshPlain);
  const admin = await Admin.findOne({ refreshTokenHash: hash });
  if (!admin) return null;
  admin.refreshTokenHash = null;
  await admin.save();
  return admin;
}

async function findByRefreshTokenHash(hash) {
  return Admin.findOne({ refreshTokenHash: hash });
}

module.exports = {
  createAdmin,
  findAdminByMobile,
  checkAdminByMobileOrEmail,
  updateAdmin,
  deleteAdmin,
  listAdmins,
  getAdminById,
  login,
  rotateRefreshToken,
  logoutByRefreshToken,
  findByRefreshTokenHash,
};
:
===== coachService.js ===== 
const Coach = require("../../models/coach/coachModel");
const { encrypt, decrypt } = require("../../utils/cryptography.util");
const getId = require("../../utils/getId.util");
const validateInputs = require("../../utils/validateInputs.util");
const path = require("path");
const fs = require("fs");
const { hashPassword, comparePassword } = require("../../utils/password.util");
const { logError } = require("../../utils/errorLogger.util");
const {
  signAccessToken,
  generateRefreshTokenPlain,
  hashRefreshToken,
  refreshTokenExpiryDate,
} = require("../../utils/jwt.util");

// Ensure these constants match your uploadConfig.js

const {
  UPLOADS_BASE_PATH = path.join(process.cwd(), "uploads"),
  PROFILE_PIC_PATH = "profile_pics",
  CERTIFICATES_PATH = "certificates",
  WORK_ASSETS_PATH = "work_assets",
  SERVER_BASE_URL,
  PORT = 9000,
} = process.env;

const BASE_URL = SERVER_BASE_URL || `http://localhost:${PORT}`;

function logWarn(prefix, filePath, err) {
  console.warn(
    prefix,
    filePath,
    process.env.NODE_ENV === "development" ? err.stack : err.message
  );
}

const { publicUrlFor } = (function () {
  // helper same as used elsewhere in your file — but ensure you export or reuse your existing publicUrlFor
  // If you already have a publicUrlFor function in that file, use the existing one. This is a fallback used below.
  return {
    publicUrlFor: (relative) => {
      const BASE_URL =
        process.env.SERVER_BASE_URL ||
        `http://localhost:${process.env.PORT || 9000}`;
      if (!relative) return relative;
      if (/^https?:\/\//i.test(relative)) return relative;
      return `${BASE_URL}/uploads/${relative.replace(/^[\/\\]+/, "")}`;
    },
  };
})();

/**
 * Upload / update / delete single certificate (certificateId may be null)
 * Returns { message, data } where data is the updated coach or the affected certificate doc
 */
async function uploadCertificateSingle(coachId, certificateId, file) {
  const coach = await Coach.findById(coachId);
  if (!coach) throw new Error("Coach not found");

  // Delete operation: certificateId provided, file not provided => delete subdoc
  if (certificateId && !file) {
    const existing = coach.certificates.id(certificateId);
    if (!existing) throw new Error("Certificate not found");
    const oldPath = existing.path || "";
    // remove subdoc
    existing.remove();

    // delete file from disk if it exists in uploads folder
    try {
      const filename = oldPath.split("/").pop();
      const filePath = path.join(
        UPLOADS_BASE_PATH,
        CERTIFICATES_PATH,
        filename
      );
      if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
    } catch (err) {
      console.warn(
        "Failed to delete certificate file:",
        err && err.message ? err.message : err
      );
    }

    await coach.save();
    return {
      message: "Certificate deleted",
      data: { deletedId: certificateId },
    };
  }

  // Update operation: certificateId + file
  if (certificateId && file) {
    const existing = coach.certificates.id(certificateId);
    if (!existing) throw new Error("Certificate not found");
    // delete old file
    try {
      const oldPath = existing.path || "";
      const filename = oldPath.split("/").pop();
      const filePath = path.join(
        UPLOADS_BASE_PATH,
        CERTIFICATES_PATH,
        filename
      );
      if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
    } catch (err) {
      console.warn(
        "Failed to delete old certificate file:",
        err && err.message ? err.message : err
      );
    }

    const relative = `${CERTIFICATES_PATH}/${file.filename}`;
    existing.path = relative;
    await coach.save();
    return {
      message: "Certificate updated",
      data: { id: existing._id, path: publicUrlFor(relative) },
    };
  }

  // Create operation: no certificateId + file
  if (!certificateId && file) {
    const relative = `${CERTIFICATES_PATH}/${file.filename}`;
    const newSubdoc = coach.certificates.create({ path: relative });
    coach.certificates.push(newSubdoc);
    await coach.save();
    return {
      message: "Certificate added",
      data: { id: newSubdoc._id, path: publicUrlFor(relative) },
    };
  }

  throw new Error(
    "Invalid request: either provide file (to create/update) or certificateId without file (to delete)."
  );
}

/**
 * Upload / update / delete single work asset (assetId may be null)
 * workAssets subdocs have 'type' and 'path'
 */
async function uploadWorkAssetSingle(coachId, assetId, file) {
  const coach = await Coach.findById(coachId);
  if (!coach) throw new Error("Coach not found");

  // Delete operation
  if (assetId && !file) {
    const existing = coach.workAssets.id(assetId);
    if (!existing) throw new Error("Work asset not found");

    const oldPath = existing.path || "";
    existing.remove();

    try {
      const filename = oldPath.split("/").pop();
      const filePath = path.join(UPLOADS_BASE_PATH, WORK_ASSETS_PATH, filename);
      if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
    } catch (err) {
      console.warn(
        "Failed to delete work asset file:",
        err && err.message ? err.message : err
      );
    }

    await coach.save();
    return { message: "Work asset deleted", data: { deletedId: assetId } };
  }

  // Update operation
  if (assetId && file) {
    const existing = coach.workAssets.id(assetId);
    if (!existing) throw new Error("Work asset not found");

    try {
      const oldPath = existing.path || "";
      const filename = oldPath.split("/").pop();
      const filePath = path.join(UPLOADS_BASE_PATH, WORK_ASSETS_PATH, filename);
      if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
    } catch (err) {
      console.warn(
        "Failed to delete old work file:",
        err && err.message ? err.message : err
      );
    }

    const type =
      file.mimetype && file.mimetype.startsWith("image") ? "image" : "video";
    const relative = `${WORK_ASSETS_PATH}/${file.filename}`;
    existing.path = relative;
    existing.type = type;
    await coach.save();
    return {
      message: "Work asset updated",
      data: { id: existing._id, path: publicUrlFor(relative), type },
    };
  }

  // Create operation
  if (!assetId && file) {
    const type =
      file.mimetype && file.mimetype.startsWith("image") ? "image" : "video";
    const relative = `${WORK_ASSETS_PATH}/${file.filename}`;
    const newSubdoc = coach.workAssets.create({ path: relative, type });
    coach.workAssets.push(newSubdoc);
    await coach.save();
    return {
      message: "Work asset added",
      data: { id: newSubdoc._id, path: publicUrlFor(relative), type },
    };
  }

  throw new Error(
    "Invalid request: either provide file (to create/update) or assetId without file (to delete)."
  );
}

/**
 * Create an unverified coach
 * - password is hashed
 */

async function createUnverifiedCoach({
  name,
  password,
  mobile,
  mobileVerified,
  agree_terms_conditions,
  agree_privacy_policy,
}) {
  const exists = await Coach.findOne({ mobile });
  if (exists) throw new Error("Mobile number already registered");

  const hashed = await hashPassword(password);
  // still keep legacy token for backward compat, but the new flow uses JWT + refresh tokens
  const legacyToken = getId(24);

  const newCoach = new Coach({
    name,
    mobile,
    password: hashed,
    mobileVerified: !!mobileVerified,
    agree_terms_conditions,
    agree_privacy_policy,
    token: legacyToken,
    status: "unverified",
  });

  await newCoach.save();
  return formatCoach(newCoach);
}

async function processOtpVerification(otpRecord, reqMeta = {}) {
  if (!otpRecord)
    return { accessToken: null, refreshTokenPlain: null, coach: null };

  let coach = null;
  if (otpRecord.meta && otpRecord.meta.coachId) {
    coach = await Coach.findById(otpRecord.meta.coachId);
  } else if (otpRecord.phone) {
    coach = await Coach.findOne({ mobile: otpRecord.phone });
  }

  if (!coach)
    return { accessToken: null, refreshTokenPlain: null, coach: null };

  // mark verified and update legacy token
  coach.mobileVerified = true;
  if (coach.status === "unverified") coach.status = "pending";
  const legacyToken = getId(24);
  coach.token = legacyToken;
  await coach.save();

  // issue tokens
  const accessToken = signAccessToken({
    sub: String(coach._id),
    role: "coach",
  });
  const refreshPlain = generateRefreshTokenPlain();
  await saveRefreshToken(coach._id, refreshPlain, reqMeta);

  return {
    accessToken,
    refreshTokenPlain: refreshPlain,
    coach: formatCoach(coach),
  };
}

/**
 * Login - validate password, issue tokens
 */
async function login(mobile, password, reqMeta = {}) {
  const coach = await Coach.findOne({ mobile });
  if (!coach) return null;
  const ok = await comparePassword(password, coach.password);
  if (!ok) return null;

  // update legacy token for compatibility
  coach.token = getId(24);
  await coach.save();

  // issue tokens
  const accessToken = signAccessToken({
    sub: String(coach._id),
    role: "coach",
  });
  const refreshPlain = generateRefreshTokenPlain();
  await saveRefreshToken(coach._id, refreshPlain, reqMeta);

  return {
    coach: formatCoach(coach),
    accessToken,
    refreshTokenPlain: refreshPlain,
  };
}

/**
 * Logout - revoke refresh token (if provided) or clear cookie
 */
async function logout(refreshTokenPlain, coachId = null) {
  // if coachId provided and no refresh token, clear all
  if (coachId && !refreshTokenPlain) {
    await clearAllRefreshTokens(coachId);
    return true;
  }

  if (!refreshTokenPlain) return false;
  // try to find coach owning this refresh token and remove it
  const tokenHash = hashRefreshToken(refreshTokenPlain);
  const coach = await Coach.findOne({ "refreshTokens.tokenHash": tokenHash });
  if (!coach) return false;
  // remove token
  coach.refreshTokens = (coach.refreshTokens || []).filter(
    (t) => t.tokenHash !== tokenHash
  );
  await coach.save();
  return true;
}

async function getCoachById(id) {
  const coach = await Coach.findById(id);
  return coach ? formatCoach(coach) : null;
}

/**
 * When client sends refresh token, verify and rotate (if valid) and issue new access token.
 * Returns { accessToken, refreshTokenPlain (if rotated), coach } or invalid reasons.
 */
async function refreshAccessToken(refreshTokenPlain, reqMeta = {}) {
  const verified = await verifyAndRotateRefreshToken(
    refreshTokenPlain,
    true,
    reqMeta
  );
  if (!verified.valid)
    return { ok: false, reason: verified.reason || "invalid" };

  const coachPayload = verified.coach;
  const coachId = coachPayload._id;
  const accessToken = signAccessToken({ sub: String(coachId), role: "coach" });

  return {
    ok: true,
    accessToken,
    refreshTokenPlain: verified.newRefreshPlain, // rotated token plain
    coach: coachPayload,
  };
}

async function setTokenForCoachById(coachId) {
  const token = getId(24);
  const updated = await Coach.findByIdAndUpdate(
    coachId,
    { token },
    { new: true }
  );
  return { coach: updated ? formatCoach(updated) : null, token };
}

async function getCoachByToken(token) {
  if (!token) return null;
  const coach = await Coach.findOne({ token });
  return coach ? formatCoach(coach) : null;
}

async function listCoaches({ page = 1, limit = 20, status, q } = {}) {
  const skip = (page - 1) * limit;
  const filter = {};
  if (status) filter.status = status;
  if (q)
    filter.$or = [
      { mobile: { $regex: q, $options: "i" } },
      { name: { $regex: q, $options: "i" } },
    ];
  const docs = await Coach.find(filter).skip(skip).limit(limit);
  return docs.map(formatCoach);
}

async function updateCoach(id, data) {
  const update = { ...data };
  if (data.password) update.password = await hashPassword(data.password);
  delete update.token;
  const updated = await Coach.findByIdAndUpdate(id, update, { new: true });
  return updated ? formatCoach(updated) : null;
}

async function coachProfileSetupService(payload) {
  const updateObj = {};
  if (payload.email) updateObj.email = payload.email;
  if (payload.dob) updateObj.dob = new Date(payload.dob);
  if (payload.gender) updateObj.gender = payload.gender;
  if (payload.country) updateObj.country = payload.country;
  if (payload.city) updateObj.city = payload.city;
  if (payload.address) updateObj.address = payload.address;
  if (payload.pincode) updateObj.pincode = payload.pincode;
  if (payload.experience_since_date)
    updateObj.experience_since_date = new Date(payload.experience_since_date);
  if (typeof payload.agree_certification === "boolean")
    updateObj.agree_certification = payload.agree_certification;
  if (typeof payload.agree_experience === "boolean")
    updateObj.agree_experience = payload.agree_experience;
  if (typeof payload.agree_refund === "boolean")
    updateObj.agree_refund = payload.agree_refund;
  if (payload.my_activities) updateObj.my_activities = payload.my_activities;
  if (payload.accepted_genders)
    updateObj.accepted_genders = payload.accepted_genders;
  if (payload.accepted_languages)
    updateObj.accepted_languages = payload.accepted_languages;

  const updatedCoach = await Coach.findOneAndUpdate(
    { _id: payload.id },
    { $set: updateObj },
    { new: true }
  );
  return updatedCoach ? formatCoach(updatedCoach) : null;
}

async function saveStoryService(payload) {
  const coach = await Coach.findOneAndUpdate(
    { _id: payload.id },
    { $set: { story: payload.story } },
    { new: true }
  );
  return coach ? formatCoach(coach) : null;
}

async function coachAgreementTermsService(payload) {
  const coach = await Coach.findByIdAndUpdate(
    payload.id,
    { $set: { agreement_terms: payload.agreement_terms } },
    { new: true }
  );
  return coach ? formatCoach(coach) : null;
}

async function changeCoachStatus(id, status) {
  if (!["unverified", "pending", "verified"].includes(status))
    throw new Error("Invalid status");
  const coach = await Coach.findById(id);
  if (!coach) return null;
  coach.status = status;
  coach.verified = status === "verified";
  await coach.save();
  return formatCoach(coach);
}

async function toggleBlockStatus(id, isBlocked) {
  const coach = await Coach.findById(id);
  if (!coach) return null;
  coach.isBlocked = !!isBlocked;
  await coach.save();
  return formatCoach(coach);
}

async function addCertificates(coachId, indexes, files) {
  const coach = await Coach.findById(coachId);
  if (!coach) return null;
  for (let i = 0; i < indexes.length; i++) {
    const idx = indexes[i];
    const file = files[i];
    const certPathRelative = file
      ? `${CERTIFICATES_PATH}/${file.filename}`
      : null;
    const publicPath = certPathRelative ? publicUrlFor(certPathRelative) : null;
    const existingIdx = coach.certificates.findIndex((c) => c.index === idx);
    if (publicPath) {
      if (existingIdx !== -1) coach.certificates[existingIdx].path = publicPath;
      else coach.certificates.push({ index: idx, path: publicPath });
    } else {
      if (existingIdx !== -1) {
        const oldUrl = coach.certificates[existingIdx].path || "";
        const filename = oldUrl.split("/").pop();
        const oldFilePath = path.join(
          UPLOADS_BASE_PATH,
          CERTIFICATES_PATH,
          filename
        );
        try {
          if (fs.existsSync(oldFilePath)) fs.unlinkSync(oldFilePath);
        } catch (err) {
          logWarn("Certificate delete failed:", oldFilePath, err);
        }
        coach.certificates.splice(existingIdx, 1);
      }
    }
  }
  await coach.save();
  return formatCoach(coach);
}

async function saveAgreement(id, title, contentArr) {
  const formatted = {
    title,
    content: (contentArr || []).map((i) => ({
      type: i.type,
      content: i.content,
    })),
  };
  const updated = await Coach.findByIdAndUpdate(
    id,
    { agreement_terms: formatted },
    { new: true }
  );
  return updated ? formatCoach(updated) : null;
}

async function saveSessionSlots(id, categoryId, sessionKey, level, payload) {
  const coach = await Coach.findById(id);
  if (!coach) return null;
  coach.category = coach.category || [];
  const catIndex = coach.category.findIndex((c) => c.id === categoryId);
  if (catIndex === -1) throw new Error("Category not found");
  coach.category[catIndex].levelOfExpertise =
    coach.category[catIndex].levelOfExpertise || [];
  if (!coach.category[catIndex].levelOfExpertise.includes(level))
    coach.category[catIndex].levelOfExpertise.push(level);
  coach.category[catIndex].session = coach.category[catIndex].session || {};
  coach.category[catIndex].session[sessionKey] = payload;
  await coach.save();
  return formatCoach(coach);
}

async function toggleLikeActivity(coachId, activityId, action = "add") {
  if (action === "add") {
    await Coach.findByIdAndUpdate(coachId, {
      $addToSet: { liked_activities: activityId },
    });
  } else {
    await Coach.findByIdAndUpdate(coachId, {
      $pull: { liked_activities: activityId },
    });
  }
  const coach = await Coach.findById(coachId);
  return formatCoach(coach);
}

async function toggleSaveCoach(coachId, savedCoachId, action = "add") {
  if (action === "add") {
    await Coach.findByIdAndUpdate(coachId, {
      $addToSet: { saved_coaches: savedCoachId },
    });
  } else {
    await Coach.findByIdAndUpdate(coachId, {
      $pull: { saved_coaches: savedCoachId },
    });
  }
  const coach = await Coach.findById(coachId);
  return formatCoach(coach);
}

async function setProfilePicture(id, fullFilePath) {
  const coach = await Coach.findById(id);
  if (!coach) return null;
  if (coach.profilePicture) {
    const oldFilename = coach.profilePicture.split("/").pop();
    const oldFilePath = path.join(
      UPLOADS_BASE_PATH,
      PROFILE_PIC_PATH,
      oldFilename
    );
    try {
      if (fs.existsSync(oldFilePath)) fs.unlinkSync(oldFilePath);
    } catch (err) {
      logWarn("Old profile picture not deleted:", oldFilePath, err);
    }
  }
  const relative = `${PROFILE_PIC_PATH}/${path.basename(fullFilePath)}`;
  coach.profilePicture = relative;
  await coach.save();
  return formatCoach(coach);
}

async function setWorkAssets(coachId, indexes, files) {
  const coach = await Coach.findById(coachId);
  if (!coach) return null;
  for (let i = 0; i < indexes.length; i++) {
    const idx = indexes[i];
    const file = files[i];
    const existingAsset = coach.workAssets.find((w) => w.index === idx);
    if (file) {
      const type = file.mimetype.startsWith("image") ? "image" : "video";
      const relative = `${WORK_ASSETS_PATH}/${file.filename}`;
      if (existingAsset) {
        const oldFilename = (existingAsset.path || "").split("/").pop();
        const oldFilePath = path.join(
          UPLOADS_BASE_PATH,
          WORK_ASSETS_PATH,
          oldFilename
        );
        try {
          if (fs.existsSync(oldFilePath)) fs.unlinkSync(oldFilePath);
        } catch (err) {
          logWarn("Old work asset not deleted:", oldFilePath, err);
        }
        existingAsset.path = relative;
        existingAsset.type = type;
      } else {
        coach.workAssets.push({ index: idx, path: relative, type });
      }
    } else if (existingAsset) {
      const oldFilename = existingAsset.path.split("/").pop();
      const oldFilePath = path.join(
        UPLOADS_BASE_PATH,
        WORK_ASSETS_PATH,
        oldFilename
      );
      try {
        if (fs.existsSync(oldFilePath)) fs.unlinkSync(oldFilePath);
      } catch (err) {
        logWarn("Work asset delete failed:", oldFilePath, err);
      }
      coach.workAssets = coach.workAssets.filter((w) => w.index !== idx);
    }
  }
  await coach.save();
  return formatCoach(coach);
}

async function buildProfile(payload) {
  let dob = null;
  if (payload.dob) {
    const parts = payload.dob.split("-").map(Number);
    if (parts.length === 3) {
      const [month, day, year] = parts;
      dob = new Date(year, month - 1, day);
    }
  }
  const tokenDecrypted = decrypt(payload.token);
  const updateObj = {
    email: payload.email,
    dob,
    gender: payload.gender,
    pinCode: payload.pin_code,
    country: payload.country,
    city: payload.city,
    address: payload.address,
    experience_year: payload.experience?.year,
    experience_months: payload.experience?.months,
    category: (payload.category || []).map((item) => ({
      id: item.id,
      coach_experties_level: item.coach_experties_level,
      session: (item.session || []).map((s) => ({
        client_experties_level: s.client_experties_level,
        session_type: s.session_type,
        avg_time: s.avg_time,
        avg_price: s.avg_price,
        currency: s.currency,
        slots: s.slots || [],
      })),
    })),
    client_gender: payload.client_gender || [],
    languages: payload.languages || [],
    verified: false,
  };
  const updatedCoach = await Coach.findOneAndUpdate(
    { token: tokenDecrypted },
    updateObj,
    { new: true }
  );
  return updatedCoach ? formatCoach(updatedCoach) : null;
}

async function deleteCoach(coachId) {
  const deletedCoach = await Coach.findByIdAndDelete(coachId);
  return deletedCoach ? formatCoach(deletedCoach) : null;
}

async function updatePassword(coachId, oldPassword, newPassword) {
  const coach = await Coach.findById(coachId);
  if (!coach) return null;
  const ok = await comparePassword(oldPassword, coach.password);
  if (!ok) return { error: "Old password is incorrect" };
  coach.password = await hashPassword(newPassword);
  await coach.save();
  return formatCoach(coach);
}

async function forgetPasswordService(mobile, newPassword) {
  if (!mobile) throw new Error("Mobile required");
  const coach = await Coach.findOne({ mobile });
  if (!coach) return null;
  coach.password = await hashPassword(newPassword);
  await coach.save();
  return formatCoach(coach);
}

async function isMobileAvailable(mobile) {
  if (!mobile) throw new Error("Mobile required");
  const coach = await Coach.findOne({ mobile });
  return !coach;
}

function formatCoach(doc) {
  if (!doc) return null;
  let d;
  try {
    d = doc.toObject ? doc.toObject() : { ...doc }; // safer
  } catch (e) {
    console.error("formatCoach error:", e.message);
    return null;
  }

  delete d.password;
  if (d.refreshTokens) delete d.refreshTokens;

  if (d.profilePicture && d.profilePicture.indexOf(BASE_URL) === -1) {
    d.profilePicture = publicUrlFor(d.profilePicture);
  }

  if (Array.isArray(d.certificates)) {
    d.certificates = d.certificates.map((c) => ({
      ...c,
      path: publicUrlFor(c.path),
    }));
  }

  if (Array.isArray(d.workAssets)) {
    d.workAssets = d.workAssets.map((w) => ({
      ...w,
      path: publicUrlFor(w.path),
    }));
  }

  return d;
}

/* ---------------------------
   Token helpers
   --------------------------- */

/**
 * Save a refresh token hashed to coach.refreshTokens array
 * returns saved metadata
 */
async function saveRefreshToken(coachId, refreshTokenPlain, reqMeta = {}) {
  const tokenHash = hashRefreshToken(refreshTokenPlain);
  const expiresAt = refreshTokenExpiryDate();
  const coach = await Coach.findById(coachId);
  if (!coach) return null;
  coach.refreshTokens = coach.refreshTokens || [];
  coach.refreshTokens.push({
    tokenHash,
    expiresAt,
    createdAt: new Date(),
    userAgent: reqMeta.userAgent || null,
    ip: reqMeta.ip || null,
  });
  await coach.save();
  return { tokenHash, expiresAt };
}

/**
 * Remove a refresh token (by plain token) from DB (logout / revoke)
 */
async function revokeRefreshToken(coachId, refreshTokenPlain) {
  const tokenHash = hashRefreshToken(refreshTokenPlain);
  const res = await Coach.findByIdAndUpdate(
    coachId,
    { $pull: { refreshTokens: { tokenHash } } },
    { new: true }
  );
  return res ? true : false;
}

/**
 * Verify a refresh token plain and return the coach if valid.
 * Optionally rotates (removes old token and inserts new one) if rotate === true.
 * Returns { coach, newRefreshTokenPlain } where newRefreshTokenPlain is present if rotation happened.
 */
async function verifyAndRotateRefreshToken(
  refreshTokenPlain,
  rotate = true,
  reqMeta = {}
) {
  const tokenHash = hashRefreshToken(refreshTokenPlain);
  // find coach containing this token and that token is not expired
  const now = new Date();
  const coach = await Coach.findOne({ "refreshTokens.tokenHash": tokenHash });
  if (!coach) return { valid: false, reason: "not_found" };

  const matched = (coach.refreshTokens || []).find(
    (t) => t.tokenHash === tokenHash
  );
  if (!matched) return { valid: false, reason: "not_found" };
  if (matched.expiresAt && matched.expiresAt < now) {
    // expired - remove it
    await Coach.findByIdAndUpdate(coach._id, {
      $pull: { refreshTokens: { tokenHash } },
    });
    return { valid: false, reason: "expired" };
  }

  // valid; optionally rotate
  let newRefreshPlain = null;
  if (rotate) {
    // remove old token and add a new one
    const newPlain = generateRefreshTokenPlain();
    const newHash = hashRefreshToken(newPlain);
    const expiresAt = refreshTokenExpiryDate();

    // atomic-ish: remove old token and push new one
    await Coach.findByIdAndUpdate(coach._id, {
      $pull: { refreshTokens: { tokenHash } },
    });

    await Coach.findByIdAndUpdate(coach._id, {
      $push: {
        refreshTokens: {
          tokenHash: newHash,
          expiresAt,
          createdAt: new Date(),
          userAgent: reqMeta.userAgent || null,
          ip: reqMeta.ip || null,
        },
      },
    });

    newRefreshPlain = newPlain;
  }

  return { valid: true, coach: formatCoach(coach), newRefreshPlain };
}

/**
 * Clear all refresh tokens for a coach (used in logout-all)
 */
async function clearAllRefreshTokens(coachId) {
  await Coach.findByIdAndUpdate(coachId, { $set: { refreshTokens: [] } });
}

async function setProfilePicture(id, fullFilePath) {
  const coach = await Coach.findById(id);
  if (!coach) return null;

  // Delete old one if ours
  if (coach.profilePicture) {
    const oldFilename = coach.profilePicture.split("/").pop();
    const oldFilePath = path.join(
      UPLOADS_BASE_PATH,
      PROFILE_PIC_PATH,
      oldFilename
    );
    try {
      if (fs.existsSync(oldFilePath)) fs.unlinkSync(oldFilePath);
    } catch (err) {
      logWarn("Old profile picture not deleted:", oldFilePath, err);
    }
  }

  const relative = `${PROFILE_PIC_PATH}/${path.basename(fullFilePath)}`;
  coach.profilePicture = relative;
  await coach.save();
  return formatCoach(coach);
}

async function setWorkAssets(coachId, indexes, files) {
  const coach = await Coach.findById(coachId);
  if (!coach) return null;

  for (let i = 0; i < indexes.length; i++) {
    const idx = indexes[i];
    const file = files[i];
    const existingAsset = coach.workAssets.find((w) => w.index === idx);

    if (file) {
      const type = file.mimetype.startsWith("image") ? "image" : "video";
      const relative = `${WORK_ASSETS_PATH}/${file.filename}`;
      const publicPath = publicUrlFor(relative);

      if (existingAsset) {
        // delete old file
        const oldFilename = (existingAsset.path || "").split("/").pop();
        const oldFilePath = path.join(
          UPLOADS_BASE_PATH,
          WORK_ASSETS_PATH,
          oldFilename
        );
        try {
          if (fs.existsSync(oldFilePath)) fs.unlinkSync(oldFilePath);
        } catch (err) {
          logWarn("Old work asset not deleted:", oldFilePath, err);
        }
        existingAsset.path = relative;
        existingAsset.type = type;
      } else {
        coach.workAssets.push({ index: idx, path: relative, type });
      }
    } else if (existingAsset) {
      const oldFilename = existingAsset.path.split("/").pop();
      const oldFilePath = path.join(
        UPLOADS_BASE_PATH,
        WORK_ASSETS_PATH,
        oldFilename
      );
      try {
        if (fs.existsSync(oldFilePath)) fs.unlinkSync(oldFilePath);
      } catch (err) {
        logWarn("Work asset delete failed:", oldFilePath, err);
      }
      coach.workAssets = coach.workAssets.filter((w) => w.index !== idx);
    }
  }

  await coach.save();
  return formatCoach(coach);
}

async function buildProfile(payload) {
  // Parse DOB if provided as MM-DD-YYYY
  let dob = null;
  if (payload.dob) {
    const parts = payload.dob.split("-").map(Number);
    if (parts.length === 3) {
      const [month, day, year] = parts;
      dob = new Date(year, month - 1, day);
    }
  }

  const tokenDecrypted = decrypt(payload.token);
  const updateObj = {
    email: payload.email,
    dob,
    gender: payload.gender,
    pinCode: payload.pin_code,
    country: payload.country,
    city: payload.city,
    address: payload.address,
    experience_year: payload.experience?.year,
    experience_months: payload.experience?.months,
    category: (payload.category || []).map((item) => ({
      id: item.id,
      coach_experties_level: item.coach_experties_level,
      session: (item.session || []).map((s) => ({
        client_experties_level: s.client_experties_level,
        session_type: s.session_type,
        avg_time: s.avg_time,
        avg_price: s.avg_price,
        currency: s.currency,
        slots: s.slots || [],
      })),
    })),
    client_gender: payload.client_gender || [],
    languages: payload.languages || [],
    verified: false,
  };

  const updatedCoach = await Coach.findOneAndUpdate(
    { token: tokenDecrypted },
    updateObj,
    { new: true }
  );
  return updatedCoach ? formatCoach(updatedCoach) : null;
}

async function deleteCoach(coachId) {
  const deletedCoach = await Coach.findByIdAndDelete(coachId);
  return deletedCoach ? formatCoach(deletedCoach) : null;
}

async function updatePassword(coachId, oldPassword, newPassword) {
  const coach = await Coach.findById(coachId);
  if (!coach) return null;
  const ok = await comparePassword(oldPassword, coach.password);
  if (!ok) return { error: "Old password is incorrect" };
  coach.password = await hashPassword(newPassword);
  await coach.save();
  return formatCoach(coach);
}

async function forgetPasswordService(mobile, newPassword) {
  if (!mobile) throw new Error("Mobile required");
  const coach = await Coach.findOne({ mobile });
  if (!coach) return null;
  coach.password = await hashPassword(newPassword);
  await coach.save();
  return formatCoach(coach);
}

async function isMobileAvailable(mobile) {
  if (!mobile) throw new Error("Mobile required");
  const coach = await Coach.findOne({ mobile });
  return !coach;
}

module.exports = {
  saveRefreshToken,
  revokeRefreshToken,
  verifyAndRotateRefreshToken,
  createUnverifiedCoach,
  processOtpVerification,
  setTokenForCoachById,
  login,
  logout,
  refreshAccessToken,
  getCoachById,
  getCoachByToken,
  listCoaches,
  updateCoach,
  changeCoachStatus,
  toggleBlockStatus,
  addCertificates,
  saveAgreement,
  saveSessionSlots,
  toggleLikeActivity,
  toggleSaveCoach,
  setProfilePicture,
  setWorkAssets,
  coachProfileSetupService,
  saveStoryService,
  coachAgreementTermsService,
  buildProfile,
  deleteCoach,
  updatePassword,
  formatCoach,
  isMobileAvailable,
  forgetPasswordService,
  uploadCertificateSingle,
  uploadWorkAssetSingle,
};
:
===== cryptography.util.js ===== 
const Cryptr = require("cryptr");

if (!process.env.CRYPTR_SECRET) {
  if (process.env.NODE_ENV === "production") {
    console.error("❌ CRYPTR_SECRET is missing in .env — exiting");
    process.exit(1);
  } else {
    console.warn("CRYPTR_SECRET missing, falling back to development secret");
  }
}

const cryptr = new Cryptr(process.env.CRYPTR_SECRET || "dev-fallback-secret");

const encrypt = (text) => {
  if (text === null || text === undefined) return null;
  return cryptr.encrypt(String(text));
};

const decrypt = (text) => {
  if (text === null || text === undefined) return null;
  try {
    return cryptr.decrypt(String(text));
  } catch (err) {
    console.warn("❌ Decrypt failed (possibly invalid token)");
    return null;
  }
};

module.exports = { encrypt, decrypt };

// EXAMPLES - how to use encryption and decryption
// const encryptedString = cryptr.encrypt("cuewellness");
// console.log(encryptedString);
// const decryptedString = cryptr.decrypt(encryptedString);
// console.log(decryptedString);
:
===== errorLogger.util.js ===== 
const ErrorModel = require("../models/errorModel");

async function logError({
  name = "error",
  file = "unknown",
  description = "",
  stack,
  section = "general",
  priority = "medium",
}) {
  try {
    const doc = new ErrorModel({
      name,
      file,
      description: String(description).slice(0, 2000),
      stack: stack ? String(stack).slice(0, 2000) : undefined,
      dateTime: new Date(),
      section,
      priority,
    });
    await doc.save();
  } catch (err) {
    // Keep noise minimal in production; only console.warn so app continues
    console.warn(
      "Failed to write error log:",
      err && err.message ? err.message : err
    );
  }
}

module.exports = { logError };
:
===== getId.util.js ===== 
module.exports = function getId(num) {
  const characters =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < num; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    result += characters[randomIndex];
  }
  return result;
};
:
===== jwt.util.js ===== 
const jwt = require("jsonwebtoken");
const crypto = require("crypto");

const JWT_SECRET = process.env.JWT_SECRET;
const ACCESS_TOKEN_EXPIRES_IN = process.env.ACCESS_TOKEN_EXPIRES_IN || "15m"; // e.g. 15m
const REFRESH_TOKEN_BYTES = parseInt(
  process.env.REFRESH_TOKEN_BYTES || "48",
  10
);
const REFRESH_TOKEN_EXPIRES_DAYS = parseInt(
  process.env.REFRESH_TOKEN_EXPIRES_DAYS || "30",
  10
);

if (!JWT_SECRET) {
  console.error("❌ JWT_SECRET missing from environment. Exiting.");
  process.exit(1);
}

/**
 * Sign an access JWT. Payload should be a plain object (avoid secrets here).
 * We'll include coach id as `sub`.
 */
function signAccessToken(payload) {
  // jwt.sign accepts `expiresIn` string like '15m'
  return jwt.sign(payload, JWT_SECRET, { expiresIn: ACCESS_TOKEN_EXPIRES_IN });
}

/**
 * Verify access token. Returns decoded payload or null on failure.
 */
function verifyAccessToken(token) {
  try {
    return jwt.verify(token, JWT_SECRET);
  } catch (err) {
    return null;
  }
}

/**
 * Generate random refresh token plain string (returned to client)
 */
function generateRefreshTokenPlain() {
  return crypto.randomBytes(REFRESH_TOKEN_BYTES).toString("hex");
}

/**
 * Hash refresh token for storage (one-way)
 */
function hashRefreshToken(refreshToken) {
  return crypto.createHash("sha256").update(String(refreshToken)).digest("hex");
}

/**
 * Compute refresh token expiry Date object based on env days
 */
function refreshTokenExpiryDate() {
  const d = new Date();
  d.setDate(d.getDate() + REFRESH_TOKEN_EXPIRES_DAYS);
  return d;
}

module.exports = {
  signAccessToken,
  verifyAccessToken,
  generateRefreshTokenPlain,
  hashRefreshToken,
  refreshTokenExpiryDate,
};
:
===== logger.js ===== 
const winston = require("winston");

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.splat(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      handleExceptions: true,
    }),
  ],
  exitOnError: false,
});

module.exports = logger;
:
===== otp.util.js ===== 
// this function will send the otp to the user
module.exports = function OTP(contact) {
  const otp = Math.floor(10000 + Math.random() * 90000);
  console.log(otp);
  return otp.toString();
};
:
===== password.util.js ===== 
const bcrypt = require("bcrypt");

const SALT_ROUNDS = parseInt(process.env.BCRYPT_SALT_ROUNDS || "12", 10);

async function hashPassword(plain) {
  if (!plain) throw new Error("Password required");
  return bcrypt.hash(plain, SALT_ROUNDS);
}

async function comparePassword(plain, hash) {
  if (!plain || !hash) return false;
  return bcrypt.compare(plain, hash);
}

module.exports = { hashPassword, comparePassword };
:
===== validateInputs.util.js ===== 
// true - you can move forward
// false - you can not move forward

module.exports = function (...values) {
  for (let i = 0; i < values.length; i++) {
    if (values[i] === "" || values[i] === null || values[i] === undefined) {
      return false;
    }
  }

  return true;
};
:
===== admin.validator.js ===== 
const Joi = require("joi");

const addAdminSchema = Joi.object({
  name: Joi.string().min(2).max(100).required(),
  mobile: Joi.string()
    .pattern(/^\+?\d{7,15}$/)
    .required(), // simple mobile validation
  email: Joi.string().email().optional().allow(null, ""),
  password: Joi.string().min(8).max(128).required(),
  dob: Joi.date().optional(),
  country: Joi.string().optional().allow("", null),
  gender: Joi.string()
    .valid("male", "female", "other")
    .optional()
    .allow("", null),
  designation: Joi.string().optional().allow("", null),
  permissions: Joi.array().items(Joi.string()).optional(),
  superAdmin: Joi.boolean().optional(),
});

const loginSchema = Joi.object({
  mobile: Joi.string()
    .pattern(/^\+?\d{7,15}$/)
    .required(),
  password: Joi.string().required(),
});

const updateAdminSchema = Joi.object({
  name: Joi.string().min(2).max(100).optional(),
  mobile: Joi.string()
    .pattern(/^\+?\d{7,15}$/)
    .optional(),
  email: Joi.string().email().optional().allow(null, ""),
  password: Joi.string().min(8).max(128).optional(),
  dob: Joi.date().optional(),
  country: Joi.string().optional().allow("", null),
  gender: Joi.string()
    .valid("male", "female", "other")
    .optional()
    .allow("", null),
  designation: Joi.string().optional().allow("", null),
  // do NOT allow permissions or superAdmin here unless requester is superAdmin (controller enforces)
  permissions: Joi.forbidden(),
  superAdmin: Joi.forbidden(),
});

module.exports = { addAdminSchema, loginSchema, updateAdminSchema };
:
